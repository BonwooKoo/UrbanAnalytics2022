---
title: "Data for Urban Analytics"
subtitle: ""
author: "Bon Woo Koo & Subhro Guhathakurta"
institute: "Georgia Institute of Technology"
date: "2022/8/30"
output:
  xaringan::moon_reader:
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    seal: false
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '4:3' # alternatives '16:9' or '4:3' or others e.g. 13:9
---
class: inverse, middle

# Intro to R - 2


.font100[
Bon Woo Koo & Subhro Guhathakurta

8/30/2022
]

```{r, include=F}
library(xaringanthemer)
library(sf)
library(tidyverse)
library(leaflet)
library(tmap)
library(kableExtra)
```

---

##.green[Content]

We will go through:

.mid[
* Handling geospatial data in R using sf package
* Loops and apply
* R Markdown + Rpubs
]

---

class: center, middle
![](./sf/sf-05.jpg)
---
class: center, middle
![](./sf/sf-06.jpg)

---
class: center, middle
![](./sf/sf-07.jpg)
---

.font180[.green[sf package in R]]

The **sf** stands simple features. 

**"Simple features are a standardized way of encoding spatial vector data (points, lines, polygons) in computers" (Pebesma, 2018, 439).**

.font90[
* *Feature* can be thought of as "things" or objects that have a spatial location or extent (e.g., building or political state).
* *Feature geometry* refers to the spatial properties (location or extent) of a feature.
* *Feature attributes* refers to other properties that features have, such as name, some measured quantity, etc.
* *Simple feature access* is an international standard for representing and encoding spatial data
]


.footnote[
This content is adopted from Pedesma (2018) [Read](https://journal.r-project.org/archive/2018/RJ-2018-009/RJ-2018-009.pdf)
]

---
class: center, middle
![](./sf/sf-09.jpg)

---
class: center, middle
![](./sf/sf-10.jpg)

---
class: center, middle
![](./sf/sf-11.jpg)

---
class: center, middle
![](./sf/sf-12.jpg)
---

* Fast reading and writing of data (but not necessarily plotting)
* sf objects can be treated as data.frames
* Works smoothly with dplyr verbs as well as %>%.
* I personally do not use ArcGIS at all. 99% of my GIS works are done in R using sf package.

![](https://r-spatial.github.io/sf/articles/sf_xfig.png)
.footnote[image source: https://r-spatial.github.io/sf/articles/sf1.html]

---
## Let's do some coding

```{r, eval=F}
library(sf)
poly <- sf::st_read("https://raw.githubusercontent.com/BonwooKoo/UrbanAnalytics2022/main/Lab/module_0/testdata.geojson")
marta <- sf::st_read("https://raw.githubusercontent.com/BonwooKoo/UrbanAnalytics2022/main/Lab/module_0/MARTA_Routes.geojson") 
```

```{r message=F, include=F}
poly <- sf::st_read("https://raw.githubusercontent.com/BonwooKoo/UrbanAnalytics2022/main/Lab/module_0/testdata.geojson")
marta <- sf::st_read("https://raw.githubusercontent.com/BonwooKoo/UrbanAnalytics2022/main/Lab/module_0/MARTA_Routes.geojson") 
```

.scriptsize[
```{r}
marta %>% print()
```
]
---
## What's inside geometry column
.footnotesize[
.scroll-box-10[
```{r}
marta[['geometry']]
```
]

```{r}
marta[['geometry']][[1]]
```
]
.scroll-box-10[.footnotesize[
```{r}
marta %>% st_coordinates()
```
]]

---
## Subsetting
#### Select by attributes
All the verbs from dplyr packages work for sf objects. Nothing new to learn.

#### Select by location
When you have two or more sf objects, you can select a subset. Let's do a demo with Census Tracts and a 10-KM buffer from the Five Points Station.

.pull-left[
.scriptsize[
```{r eval=F}
fp.buffer <- five_point %>% st_buffer(dist = 10000)#<<
  
leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data = poly, weight=1, color="grey") %>% 
  addPolygons(data = fp.buffer, weight=1) %>% 
  addLegend("bottomright", 
            colors = c("blue", "grey"), 
            labels = c("Five Points Buffer", 
                       "Census Tract Boundary"), 
            title="Legend")
```
]]

.pull-right[
.script-size[
```{r echo=F, message=F, warning=F}
fp.buffer <- suppressWarnings(five_point %>% st_buffer(dist = 10000)) 
  
leaflet(height=330, width="100%") %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data = poly, weight=1, color="grey") %>% 
  addPolygons(data = fp.buffer, weight=1) %>% 
  addLegend("bottomright", 
            colors = c("blue", "grey"), 
            labels = c("Five Points Buffer", 
                       "Census Tract Boundary"), 
            title="Legend")
```
]]
---

## Subsetting
The magic syntax is: 

.center[.red[sf-obj-1][.blue[sf-obj-2], , .green[operation]]]


```{r}

```

---
class: center, middle
![](./sf/sf-18.jpg)

---
class: center, middle
![](./sf/sf-19.jpg)

---
class: center, middle
![](./sf/sf-20.jpg)

---
class: center, middle
![](./sf/sf-21.jpg)

---
---
## Visualizing linestring and points
Let's visualize the first LINESTRING (i.e., Blue Line of MARTA) and the points that makes the LINESTRING.


.pull-left[
#### Extracting points
.scroll-box-20[
.footnotesize[
```{r}
marta.point <- marta %>% 
  # Extract the first row
  slice(2) %>% 
  # Turn it into coordinates
  st_coordinates() %>% 
  # Turn it into df
  as.data.frame() %>% 
  # df to sf
  st_as_sf(coords = c("X", "Y"), 
           crs = 4326)

marta.point
```
]
]
]

.pull-right[
#### Extracing line
.scroll-box-20[
.footnotesize[
```{r}
marta.line <- marta %>% 
  # Extract the first row
  slice(2) 

marta.line
```
]
]
]
---
## (A side note)Plotting them together

```{r out.width="100%", out.height="50%"}
library(leaflet)
leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% # Background map
  addPolylines(data = marta %>% slice(c(1,3)), 
               color="grey", weight=1) %>% # Adding non-Blue lines
  addPolylines(data = marta.line) %>% # Adding marta.line #<<
  addCircles(data = marta.point) # Adding marta.point #<<
```

---
## Why this is useful
Being able to parse the geometry at point level allows us to do any manipulation we want to do. 

For example, we want to cut the line into two at near Five Points Station (33.7539, -84.3916).
.footnotesize[
.scroll-box-14[
```{r}
# Creating POINT feature for five point station
five_point <- st_point(c(-84.3916, 33.7539)) %>% st_sfc(crs = 4326)

# Calculate pairwise distance to all points that define Gold line
dist.mat <- marta.point %>% st_distance(five_point)

# Which row contains the closest point?
closest.pnt <- which.min(dist.mat)

# Parse marta.line and create a cut-off line
marta.line.cut <- marta.line %>% 
  st_coordinates() %>% as.data.frame() %>% 
  mutate(break.point = c(rep("South",closest.pnt), rep("North",nrow(.)-closest.pnt))) %>% 
  st_as_sf(coords=c("X", "Y"), crs = 4326) %>% 
  group_by(break.point, L1) %>% summarise(do_union=FALSE) %>% st_cast("LINESTRING") %>% 
  group_by(break.point) %>% summarise(do_union=FALSE) %>% st_cast("MULTILINESTRING")

marta.line.cut
```
]
]

.center[
### No need to understand this code! I just wanted to demonstrate what can be done.
]
---
.scriptsize[
```{r, out.width="100%", out.height="50%"}
pal <- colorFactor(palette = c("red", "blue"), domain = marta.line.cut$break.point)
  
leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolylines(data = marta.line.cut, color = ~pal(break.point)) %>% 
  addPolylines(data = marta %>% slice(1,3), color="grey", weight=1) %>% 
  addCircles(data=five_point, color="black", radius=300) %>% 
  addLegend("bottomright", pal = pal, values = marta.line.cut$break.point)
```
]
