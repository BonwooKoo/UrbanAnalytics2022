---
title: "Week # - Accessing and Processing GTFS"
author: "Bonwoo Koo"
date: '2022-07-14'
output: rmdformats::downcute
---

<style type="text/css">
  body{
  font: Helvetica;
}
</style>

Useful Links:

* [tidytransit Vignettes](https://cran.r-project.org/web/packages/tidytransit/index.html)
* [Google GTFS](https://developers.google.com/transit/gtfs/reference)

# Environment Setting
```{r message=FALSE, warning=FALSE}
# Import required packages
library(tidytransit)
library(tidyverse)
library(tmap)
library(ggplot2)
library(gtfsrouter)
library(here)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(plotly)
library(igraph)
library(tidygraph)
library(dodgr)

# setwd("D:/Dropbox (GaTech)/Work/Working/School/UA_2022/Lab/W3/")
setwd("C:/Users/bkoo34/Dropbox (GaTech)/work/working/School/UA_2022/lab/w3")
```

# Read GTFS Feed

Let's download some GTFS feed provided by Metropolitan Atlanta Rapid Transit Authority (MARTA).
```{r, results='hide'}
# From ULR
download_dest <- here::here(getwd(), "GTFS_MARTA.zip")
gtfs_local <- download.file("http://www.itsmarta.com/google_transit_feed/google_transit.zip", destfile = download_dest)


atl <- tidytransit::read_gtfs("http://www.itsmarta.com/google_transit_feed/google_transit.zip")
atl_temp <- gtfsrouter::extract_gtfs(download_dest)

# Take a look
summary(atl)
```

GTFS feed contains many relational tables about transit service schedules, trips, stops, and routes.

### Where to get the URL?
Here are some other sources of GTFS feeds:

* https://database.mobilitydata.org/
* https://www.transit.land/

Transit agencies (e.g., MARTA) may provide their feeds on their website as well. For example, I found the data we are using today by Googling 'MARTA GTFS' and got it from this [website](https://transitfeeds.com/p/marta/65) (look for *Official Download URL* in the website).

# Understand what's inside `atl`
```{r}
typeof(atl)
names(atl)
head(atl$calendar)
```
The `atl` object is a list. In it, `names(atl)` shows that there are `r length(atl)` dataframes. These dataframes can be linked to each other using *join keys*. The diagram below shows how different tables are linked.

```{r echo=FALSE, out.width="500px"}
url <- "http://tidytransit.r-transit.org/articles/figures/GTFS_class_diagram.svg.png"
knitr::include_graphics(url)
```

IMAGE SOURCE: http://tidytransit.r-transit.org/articles/introduction.html

<br>
```{r}

```

The table below shows a brief description of what each dataframe contains. This table is taken from [Google](https://developers.google.com/transit/gtfs/reference#routestxt).

Filename                  Defines
----------------------    ---------------------    
agency                    Transit agencies with service represented in this dataset.                     
stops                     Stops where vehicles pick up or drop off riders. Also defines stations and station entrances.
routes                    Transit routes. A route is a group of trips that are displayed to riders as a single service.
trips                     Trips for each route. A trip is a sequence of two or more stops that occur during a specific time period.
stop_times                Times that a vehicle arrives at and departs from stops for each trip.
calendar                  Service dates specified using a weekly schedule with start and end dates. This file is required unless all dates of service are defined in calendar_dates.txt.
calendar_dates            Exceptions for the services defined in the calendar.txt. If calendar.txt is omitted, then calendar_dates.txt is required and must contain all dates of service.
fare_attributes           Fare information for a transit agency's routes.
fare_rules                Rules to apply fares for itineraries.
shapes                    Rules for mapping vehicle travel paths, sometimes referred to as route alignments.
frequencies               Headway (time between trips) for headway-based service or a compressed representation of fixed-schedule service.
transfer                  Rules for making connections at transfer points between routes.
pathways                  Pathways linking together locations within stations.
levels                    Levels within stations.
feed_into                 Dataset metadata, including publisher, version, and expiration information.
translations              Translated information of a transit agency.
attributions              Specifies the attributions that are applied to the dataset.
----------------------    ---------------------    

# GTFS into geospatial format

The function `gtfs_as_sf` converts 'shapes' and 'stops' tables in GTFS data into sf objects.

```{r}
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
head(atlsf)
```

```{r}
# Interactive mapping
tmap::tmap_mode('view')
m1 <- tmap::tm_shape(atlsf$shapes) + tmap::tm_lines(alpha = 0.5)
m2 <- tmap::tm_shape(atlsf$stops) + tmap::tm_dots(id = 'stop_name', alpha = 0.5)

tmap::tmap_arrange(m1, m2, sync = T)
```

```{r}
# If using ggplot2 package
ggplot2::ggplot(data = atlsf$stops) +
  ggplot2::geom_sf()
```

<br>

# Calculate travel time

The tidytransit package offers a very convenient function that calculates the shortest travel times from a stop to all other stops. Try `?tidytransit::travel_times` to see what this function does and what arguments it takes.

Notice that only two out of nine arguments are required, and the rest are optional. The required arguments are 'filtered_stop_times' and 'stop_name.' If you do not provide the optional arguments, the function will use the pre-populated values for the calculation.

One of two arguments, filtered_stop_times, can be generated using the function `tidytransit::filter_stop_times()`. This function 

```{r}
## Filtered stop times

# net <- dodgr_streetnet_sc (pts = atl$stops [, c ("stop_lon", "stop_lat")])
# atl$transfers <- gtfs_transfer_table(atl)
# 
# x <- gtfs_traveltimes (atl_temp,
#                        from = "DUNWOODY STATION",
#                        start_time_limits = c (12, 13) * 3600)
# 
# fst <- filter_stop_times(gtfs_obj = atl, 
#                          extract_date = "2022-04-24", 
#                          min_departure_time = "06:00:00", 
#                          max_arrival_time = "10:00:00")
# 
# # travel_times
# trvt <- travel_times(filtered_stop_times = fst,
#                      stop_name = "MIDTOWN STATION",
#                      return_coords = TRUE)
```

# Calculate area of service by SES

GTFS from MARTA contains information about both rails and buses. The 'routes' table in `atl` has a column named 'route_type,' which contains integer values denoting types of transit service. To see what each integer means, you will need to look at the link to the Reference provided above (or see below for a screen capture from the Reference). 

![Reference from Google](D:/Dropbox (GaTech)/Work/Working/School/UA_2022/Lab/W3/GTFS_route_types.JPG)

'routes' table contains route_types, which is needed for seperating rail transit.
'shapes' table contains the shapefile needed for geooperations such as buffer, intersections, etc.
Because 'routes' and 'shapes' table do not contain a common key, they need to be joined through 'trips' as intermediary table.

```{r}
# Filter out rail transit
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")

unique_shape <- route_trip %>% 
  dplyr::group_by(route_id) %>% 
  dplyr::slice(1) %>% 
  dplyr::ungroup()

route.shape <- atlsf$shape %>% inner_join(unique_shape, by = "shape_id")

# Route type is not really intuitive - let's fix that
route.shape <- route.shape %>% 
  dplyr::mutate(route_type = dplyr::case_when(
    route_type == "0" ~ 'Tram, Streetcar',
    route_type == "1" ~ 'Subway, Metro',
    route_type == "2" ~ 'Rail',
    route_type == "3" ~ 'Bus'
  ))
```

```{r}
pal <- leaflet::colorFactor(c("red", "orange", "pink"), domain = route.shape$route_type)

route.shape %>% 
  leaflet::leaflet(data = .) %>% 
    leaflet::addProviderTiles(providers$CartoDB.DarkMatter) %>% 
    leaflet::addPolylines(color = ~pal(route_type), 
                 weight = 3,
                 opacity = 0.9,
                 popup = paste0("Route type: ", route.shape$route_type))
  
```

Until Version 1.0, the sf package used 'equirectangular projection' for many operations that involve, for example, `intersects`, `intersection`, `union`, `nearest_point`, `st_join`, etc. It did so even when the given data is in geographical coordinates.

From Version 1.0, sf package uses S2 spherical geometry for spatial operations, based on S2 geometry library written by Google. For more information on what all of these means, you can read [this post](https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry).

```{r}
# If we do not convert CRS to a projected one, the buffer may generate a ragged boundaries. 
# https://r-spatial.github.io/sf/articles/sf7.html#buffers-1
# https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry
sf::sf_use_s2(TRUE)
MARTA_buffer <- route.shape %>% 
  sf::st_transform(crs = 26967) %>% 
  sf::st_buffer(dist = units::set_units(400, "m")) 

MARTA_buffer_group <- MARTA_buffer %>% 
  group_by(route_type) %>% 
  summarise()
```

# Overlaying GTFS with Census

```{r message=FALSE, warning=FALSE, echo=FALSE, results='hide'}
# Get American Community Survey
acs2020 <- tidycensus::get_acs(geography = "tract",
                   variables = c("hhinc" = 'B19013_001',
                                 "r_tot" = "B02001_001",
                                 "r_wh" = "B02001_002",
                                 "r_bl" = "B02001_003",
                                 "tot_hh" = "B25044_001",
                                 "own_novhc" = "B25044_003",
                                 "rent_novhc" = "B25044_010"),
                   year = 2020,
                   output = "wide",
                   state = "GA",
                   county = c("Fulton", "DeKalb", "Clayton"),
                   geometry = TRUE) 

acs2020
```

```{r, out.width="100%"}
acs2020c <- acs2020 %>% 
  select(GEOID,
         hhinc = hhincE,
         r_tot = r_totE,
         r_wh = r_whE,
         r_bl = r_blE,
         tot_hh = tot_hhE,
         own_novhc = own_novhcE,
         rent_novhc = rent_novhcE) %>% 
  mutate(pct_wh = r_wh / r_tot,
         pct_bl = r_bl / r_tot,
         pct_novhc = (own_novhc + rent_novhc)/tot_hh) %>% 
  mutate(area1 = unclass(st_area(.))) %>% 
  st_transform(26967) %>% 
  mutate(area2 = unclass(st_area(.))) %>% 
  st_transform(crs = 4326) %>% 
  mutate(ln_pop_den = log((r_tot / (area1/1000^2)) + 1)) %>% 
  filter(!is.na(hhinc), !is.na(r_tot), !is.na(own_novhc))

pal1 <- colorNumeric(palette = "YlOrRd", domain = acs2020c$hhinc)
pal2 <- colorFactor("Spectral", domain = MARTA_buffer_group$route_type)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.DarkMatter) %>% 
  addPolygons(group = "ACS",
              data = acs2020c, 
              color = "grey", 
              fillColor = ~pal1(hhinc), 
              fillOpacity = 0.5,
              weight = 1, 
              popup = leafpop::popupTable(round(st_drop_geometry(acs2020c[,c("hhinc", "pct_wh", "pct_bl")]),2))) %>% 
  addPolygons(group = "MARTA",
              data = MARTA_buffer_group %>% 
                st_transform(crs = st_crs(acs2020c)), 
              color = ~pal2(route_type),
              weight = 1,
              opacity = 0.9) %>% 
  addLayersControl(
    overlayGroups = c("ACS", "MARTA"),
    options = layersControlOptions(collapsed = FALSE)
  )
```

```{r}
# Intersect buffer with tract 
buffer_per_tract1 <- acs2020c %>% 
  st_transform(crs = 26967) %>% 
  st_intersection(MARTA_buffer_group) %>% 
  filter(route_type == "Bus") %>% 
  # After Intersection
  mutate(subarea = unclass(st_area(.)),
         pct_served1 = subarea/area1,
         pct_served2 = subarea/area2) %>% 
  st_transform(crs = 4326)

buffer_per_tract2 <- acs2020c %>% 
  left_join(buffer_per_tract1 %>% select(GEOID, pct_served1) %>% st_set_geometry(NULL),
            by = "GEOID") %>% 
  # There are many NAs in the pct_served1 column
  mutate(pct_served1 = case_when(is.na(pct_served1) ~ 0,
                                 TRUE ~ pct_served1))

pal <- colorNumeric(palette = "YlOrRd", domain = buffer_per_tract2$pct_served1)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.DarkMatter) %>% 
  addPolygons(data = buffer_per_tract2, 
              fillColor = ~pal(pct_served1), fillOpacity = 0.9, 
              color = "white", opacity = 0.2, 
              weight = 1) %>% 
  addLegend("bottomright",
            pal = pal,
            values = buffer_per_tract2$pct_served1,
            title = "% Area within 400m from transit line") 
```

Be careful when calculating area. `tm_shape( buffer_per_tract %>% mutate(diff = (area2 - area1)/area2)) + tm_polygons(col = 'diff', style = 'quantile')`

```{r}
# Is there any correlation between SES and service area?
var_name <- list(
  'hhinc'="Annual Household Income",
  'pct_bl'="% Black population",
  'pct_novhc'="% Household without vehicle",
  'pct_wh'="% White population",
  'r_tot'="Total population",
  'ln_pop_den' = "Population density"
)

var_labeller <- function(variable, value){
  return(var_name[value])
}

na_index <- buffer_per_tract2 %>% 
  select(hhinc, r_tot, ln_pop_den, starts_with('pct')) %>% 
  is.na(.) %>% 
  apply(., 1, function(x) sum(x)==0)

buffer_per_tract2 %>% 
  filter(na_index) %>% 
  pivot_longer(cols = c('hhinc', 'pct_wh', 'pct_bl', 'pct_novhc', "r_tot", "ln_pop_den"), names_to = "variable", values_to = "value") %>% 
  ggplot() +
  geom_point(aes(x = pct_served1, y = value), alpha = 0.4) +
  facet_wrap(~variable, scales = "free_y", labeller = var_labeller) +
  labs(x = "% Area with 400m beffer from transit line") +
  theme_bw()
```


```{r}
test_var <- c("hhinc", "pct_bl", "pct_wh", "pct_novhc", "r_tot", "ln_pop_den")

map_chr(test_var, function(x){
  cor.object <- cor.test(buffer_per_tract2[['pct_served1']], 
                         buffer_per_tract2[[x]])
  r <- round(cor.object$estimate,3)
  t <- round(cor.object$statistic,3)
  p <- round(cor.object$p.value,3)
  return(paste0("for ",x ,", r=", r, " (t=", t, ", p=", p, ")"))
})

```


# Reflecting the frequency differences


```{r}
# Extract MARTA rail route_id
rail_route_id <- atl$routes %>% filter(route_type == '1') %>% .[["route_id"]]

# trip_id for rails
rail_trip_id <- atl$trips %>% filter(route_id %in% rail_route_id) %>% .[['trip_id']]

# stop_id for rails
rail_stop_id <- atl$stop_times %>% filter(trip_id %in% rail_trip_id) %>% with(unique(.[["stop_id"]]))

# calculate the total number of trips passed through each stop
n_per_stop <- atlsf$stops %>% 
  left_join(
    atl$stop_times %>%
      group_by(stop_id) %>% 
      summarise(pass_count = n()) %>% 
      ungroup() %>% 
      filter(pass_count < 2000),
    by = "stop_id"
    ) %>% 
  mutate(stop_type = case_when(
    stop_id %in% rail_stop_id ~ "Rail",
    TRUE ~ "Others"
  ))

pal <- colorQuantile(palette = "YlOrRd", domain = n_per_stop$pass_count)

# Merge it with 'stop' geometry for visualization
rail_stops <- n_per_stop %>% filter(stop_type == "Rail")
other_stops <- n_per_stop %>% filter(stop_type == "Others")

n_per_stop_rail <- leaflet() %>% 
    addProviderTiles(providers$CartoDB.DarkMatter) %>% 
    addCircles(data = rail_stops,
               color = ~pal(pass_count),
               weight = 6,
               opacity = 0.5,
               popup = as.character(paste0("Count: ", rail_stops$pass_count, ", ID: ", rail_stops$stop_id)))

n_per_stop_others <- leaflet() %>% 
  addProviderTiles(providers$CartoDB.DarkMatter) %>% 
  addCircles(data = other_stops,
               color = ~pal(pass_count),
               weight = 6,
               opacity = 0.5,
               popup = as.character(paste0("Count: ", other_stops$pass_count, ", ID: ", other_stops$stop_id))) %>% 
  addLegend("bottomright", 
            pal = pal, 
            values = n_per_stop$pass_count,
            title = "Total Stops",
            opacity = 1)

leafsync::sync(n_per_stop_rail, n_per_stop_others)
```

## Merge frequency by stop information with ACS data

```{r}
stop_tract <- acs2020c %>% 
  st_transform(crs = 4326) %>% 
  st_join(n_per_stop) %>% 
  group_by(GEOID) %>% 
  summarise(stop_count = sum(!is.na(pass_count)),
            pass_count = sum(pass_count, na.rm = T),
            hhinc = mean(hhinc),
            r_tot = mean(r_tot),
            pct_wh = mean(pct_wh),
            pct_bl = mean(pct_bl),
            pct_novhc = mean(pct_novhc),
            r_tot = mean(r_tot),
            ln_pop_den = mean(ln_pop_den))

stop_tract
```

```{r fig.align="center", echo = FALSE, out.width="100%", fig.height=10}
# Is there any correlation between SES and service area?
stop_tract_plot <- stop_tract %>% 
  mutate(hhinc = log(hhinc),
         pct_novhc = log(pct_novhc + 0.02)) %>% 
  pivot_longer(cols = c('hhinc', 'pct_wh', 'pct_bl', 'pct_novhc', "r_tot", "ln_pop_den"), 
               names_to = "variable", values_to = "value") %>%
  mutate(variable = factor(variable, labels = c('Household Income', "Population Density", "% Black", 
                                      "% No car", "% White", "Total Population")))

stop_count <- stop_tract_plot %>% 
  ggplot() +
  geom_point(aes(x = stop_count, y = value), alpha = 0.2) +
  facet_wrap(~variable, scales = "free_y") +
  labs(x = "Count of bus stops", title = "Stop Count VS. Socio-demographics") +
  theme_bw()

pass_count <- stop_tract_plot %>% 
  ggplot() +
  geom_point(aes(x = pass_count, y = value), alpha = 0.2) +
  facet_wrap(~variable, scales = "free_y") +
  labs(x = "Count of bus stops", title = "Pass Count VS. Socio-demographics") +
  theme_bw()

ggpubr::ggarrange(stop_count + ggpubr::stat_cor(aes(x = stop_count, y = value)),
                  pass_count + ggpubr::stat_cor(aes(x = pass_count, y = value)),
                  ncol = 1, nrow = 2,
                  heights = 1000)
```


```{r}
plotly::ggplotly(stop_count)
plotly::ggplotly(pass_count)
```


# Open Street Map

https://journal.r-project.org/archive/2013/RJ-2013-005/RJ-2013-005.pdf

https://r-spatial.org/r/2019/09/26/spatial-networks.html

https://cran.r-project.org/web/packages/dodgr/vignettes/dodgr.html

```{r}
library(osmdata)

# Get bounding box coordinates for Atlanta
bb <- getbb('Fulton County, GA')

bb_sf <- bb %>% t %>% data.frame() %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
  st_bbox() %>% 
  st_as_sfc()

# To see where bb covers
bb_sf %>% 
  tm_shape() + tm_borders()
```

[OSM wiki](https://wiki.openstreetmap.org/wiki/Map_features) provides a detailed description on various 'key-value' pairs.

```{r}
# Get OSM road data
osm_road <- opq(bbox = bb) %>%
  add_osm_feature(key = 'highway', 
                  value = c('motorway','primary','secondary', 'teriary', "road",
                            'residential')) %>%
  osmdata_sf() %>% 
  osm_poly2line()

names(osm_road)
```

```{r}
tm_shape(osm_road$osm_lines) + tm_lines(col = "highway")
```

```{r}
table(osm_road$osm_lines$highway)
```

# Calculating network centrality

```{r}
# # get OSM
# net <- dodgr::dodgr_streetnet(bb)
# # get weighted graph
# net <- weight_streetnet(net, wt_profile = "foot")
net <- weight_streetnet(osm_road$osm_lines, wt_profile = "foot")
# remove redundant vertices
cnet <- dodgr_contract_graph(net)
# centrality (output is the the same graph with an added column 'centrality')
cnet <- dodgr_centrality (cnet)
# Map back to original full network
cnet_full <- dodgr_uncontract_graph (cnet)
# Merge directed edges into equivalent undirected values by aggregating across directions. This function is primarily intended to aid visualisation of directed graphs,
cnet_sf <- merge_directed_graph (cnet_full) %>%
    dodgr_to_sf ()
```

```{r}
pal <- colorQuantile(palette = "YlOrRd", domain = cnet_sf$centrality)

leaflet() %>% 
  addProviderTiles(providers$CartoDB.DarkMatter) %>% 
  addPolylines(data = cnet_sf, color = ~pal(centrality), weight = 2)
```

# Merge it with Census data

```{r}
census_centrality <- acs2020c[bb_sf, ,op = st_within] %>% 
  st_join(cnet_sf) %>% 
  group_by(GEOID) %>% 
  summarise(n = n(),
            hhinc = mean(hhinc, na.rm = T),
            pct_wh = mean(pct_wh, na.rm = T),
            pct_bl = mean(pct_bl, na.rm = T),
            pct_novhc = mean(pct_novhc, na.rm = T),
            centrality = mean(centrality, na.rm = T))
```

```{r}
tm_shape(acs2020c) + tm_polygons(col = "grey", alpha = 0.5) + 
  tm_shape(census_centrality) + tm_polygons(col = "centrality", style = "quantile") + 
  tm_shape(bb_sf) + tm_borders()
```

```{r}
census_centrality_plot <- census_centrality %>% 
  mutate(hhinc = log(hhinc),
         pct_novhc = log(pct_novhc + 0.02)) %>% 
  pivot_longer(cols = c('hhinc', 'pct_wh', 'pct_bl', 'pct_novhc'), names_to = "variable", values_to = "value")

centrality_plot <- census_centrality_plot %>% 
  ggplot() +
  geom_point(aes(x = centrality, y = value), alpha = 0.2) +
  facet_wrap(~variable, scales = "free_y", labeller = var_labeller) +
  labs(x = "Centrality", title = "Centrality VS. Socio-demographics") +
  theme_bw() 

centrality_plot + ggpubr::stat_cor(aes(x = centrality, y = value))

ggplotly(centrality_plot)
```


