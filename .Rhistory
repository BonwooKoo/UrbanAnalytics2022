library(reshape2)
library(here)
library(yelpr)
library(knitr)
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
tract %>% head() %>% knitr::kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
# Retaining only those I want.
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
# Function: Get tract-wise radius
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
epsg_id <- 4326 # Edit (9/8/2022): 4326 measures distance in meter. Before the edit, I used 26967.
r4all_loop <- vector("list", nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
# Appending X Y coordinates as seprate columns
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
tmap_mode('view')
# Select the first 10 rows
ready_4_yelp[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(tract[1:10,]) + tm_borders(col= 'blue')
# Function for formatting the url for API request
url_format <- function(latitude = NULL, longitude = NULL,
radius = NULL, categories = NULL, offset = NULL, limit = NULL){
# Parameters
base_url <- "https://api.yelp.com/v3/businesses/search?"
latitude <- paste0("latitude=", latitude)
longitude <- paste0("longitude=", longitude)
radius <- paste0("radius=", radius)
categories <- paste0("categories=", categories)
offset <- paste0("offset=", offset)
limit <- paste0("limit=", limit)
# Out
full_url <- paste0(c(base_url, latitude, longitude, radius, categories, offset, limit), collapse = "&")
return(full_url)
}
# Run url_format function
full_url <- url_format(latitude = 33.792479078196294, # This is Atlantic station
longitude = -84.39676077444938, # This is Atlantic station
radius=1000,
categories="restaurant",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
# Parse the body of the response (json format)
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed$businesses %>% head %>% kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
resp_raw <- content(resp, as = "raw")
resp_raw
test_h <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'hotel', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
which_tract <- 1
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'hotel', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
?business_search
# Run url_format function
full_url <- url_format(latitude = 33.792479078196294, # This is Atlantic station
longitude = -84.39676077444938, # This is Atlantic station
radius=1000,
categories="hotel",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed$businesses %>% head %>% kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
resp_parsed
ready_4_yelp$y[which_tract]
ready_4_yelp$x[which_tract]
test_1
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'grocery', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test_1
rm(test_1)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'grocery', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
ready_4_yelp$y[which_tract]
# Run url_format function
full_url <- url_format(latitude = ready_4_yelp$y[which_tract], # This is Atlantic station
longitude = ready_4_yelp$x[which_tract], # This is Atlantic station
radius=round(ready_4_yelp$radius[which_tract]),
categories="restaurant",
offset = 0,
limit = 50)
# Run url_format function
full_url <- url_format(latitude = ready_4_yelp$y[which_tract], # This is Atlantic station
longitude = ready_4_yelp$x[which_tract], # This is Atlantic station
radius=round(ready_4_yelp$radius[which_tract]),
categories="hotel",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
# Parse the body of the response (json format)
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
resp_parsed
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'grocery', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'hotel', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'shopping', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'shopping', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'hotels', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'hair', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'arts', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'Restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'restaurant', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
# categories = 'restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
knitr::opts_chunk$set(echo = TRUE)
census_api <- Sys.getenv("census_api")
yelp_api <- Sys.getenv("yelp_api")
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
# Function: Get tract-wise radius, used in for-loop later
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
##set coordinate system
epsg_id <- 4326
# Function for formatting the url for API request
url_format <- function(latitude = NULL, longitude = NULL,
radius = NULL, categories = NULL, offset = NULL, limit = NULL){
# Parameters
base_url <- "https://api.yelp.com/v3/businesses/search?"
latitude <- paste0("latitude=", latitude)
longitude <- paste0("longitude=", longitude)
radius <- paste0("radius=", radius)
categories <- paste0("categories=", categories)
offset <- paste0("offset=", offset)
limit <- paste0("limit=", limit)
# Out
full_url <- paste0(c(base_url, latitude, longitude, radius, categories, offset, limit), collapse = "&")
return(full_url)
}
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0 when n = 1
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# out is where the results will be appended to.
out <- vector("list", required_n)
# Store the business information to nth slot in out
out[[n]] <- resp$businesses
# Change the name of the elements to the total required_n
# This is to know if there are more than 1000 businesses,
# we know how many.
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
# glue formats string by inserting {n} with what's currently stored in object n.
print(glue::glue("{n}th row has >= 1000 businesses."))
# Stop before going into the loop because we need to
# break down Census Tract to something smaller.
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
# Merge all elements in the list into a single data frame
out <- out %>% bind_rows()
return(out)
}
}
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "NJ",
county = c("Essex"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
census_api_key(Sys.getenv('yelp_api'))
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "NJ",
county = c("Essex"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
census_api_key(Sys.getenv('census_api'))
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "NJ",
county = c("Essex"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data, ROWS AND COLUMNS
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
# This function is for neatly displaying tables on HTML document.
tract %>% head() %>% knitr::kable()
# Retaining only columns that end in E (estimate) and discard M (margin)
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
#empty dataframe for census tracts
r4all_loop <- vector("list", nrow(tract))
#start for-loop to get radii for each census tract
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
tmap_mode('view')
ready_4_yelp
?str_detect
library(tidyverse)
?str_detect
a <- c("yoga", "yoga, tie")
str_detect(a, "yoga")
a <- c("yoga", "yoga, tie", "he")
str_detect(a, "yoga")
str_detect(a, ['yoga'])
str_detect(a, '[yoga]')
str_detect(a, '[Yoga]')
xaringan:::inf_mr()
grepl("yoga", c("yoga studio", "health gym", "pizza", "Yoga"))
str_detect(c("yoga studio", "health gym", "pizza", "Yoga"), "yoga")
grepl("[yY]", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[yYgG]", c("yoga studio", "health gym", "pizza", "Yoga"))
?grepl
?str_detect
grepl("[(yoga)|(Yoga)]", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[Yoga]", c("yoga studio", "health gym", "pizza", "Yoga"))
a <- read_rds("C:/Users/bonwo/Downloads/yelp_all_list_4_Anuradha.rds")
a
aa <- bind_rows(a)
aa
aa$categories
grepl("yoga", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("yoga", c("yoga studio", "health gym", "pizza", "Yoga"), fixed = F)
grepl("Yoga", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[yY]oga", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[yY]oga", c("yoga studio", "health gym", "pizza", "Yoga power"))
grepl("[yY]oga", c("yoga studio", "health gym", "pizza", "YoGa power"))
?grepl
xaringan:::inf_mr()
xaringan:::inf_mr()
source("~/.active-rstudio-document", echo=TRUE)
tfruns::training_run("D:/Dropbox (GaTech)/Work/Working/School/UA_2022/external/Lab/module_1/week2/Module1_Tidy_Yelp_Slide.Rmd")
xaringan:::inf_mr()
library(jsonlite)
