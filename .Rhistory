pivot_wider(id_cols = name, # unique identifier
names_from = treatment, # from which columns should the new column names come?
values_from = result)) # from which columns should the values come?
dupl_df <- data.frame(name = c("A", "A", "B", "C", "C", "C", "D"),
GPA = c(3.5, 3.5, 4.0, 2.0, 3.0, 3.0, 2.0))
# Base R
duplicated(dupl_df$name)
# Duplicates in column "name" removed.
dupl_df[!duplicated(dupl_df$name),]
dupl_df %>% distinct(GPA)
dupl_df %>% distinct(name, GPA)
dupl_df %>% distinct(GPA) %>% is.vector()
dupl_df %>% distinct(GPA) %>% is.data.frame()
?distinct
nchar("a b")
nchar("ab")
my_yelp %>%
apply(., 2, function(x) sum(is.na(x)))
library(tidyverse)
library(sf)
library(here)
library(tmap)
library(tidyverse) # tidyr is included in tidyverse package.
# Toy dataset
toy_df <- data.frame(name = c("John", "Jane", "Mary"),
treatment_a = c(NA, 16, 3),
treatment_b = c(2, 11, 1),
treatment_c = c(6, 12, NA))
print(toy_df)
# pivot longer
(toy_long <- toy_df %>%
pivot_longer(cols = treatment_a:treatment_c,
names_to = 'treatment', # new column name for 'cols' in character
values_to = 'result')) # new name for the column storing the values in character
# back to wider
(toy_wide <- toy_long %>%
pivot_wider(id_cols = name, # unique identifier
names_from = treatment, # from which columns should the new column names come?
values_from = result)) # from which columns should the values come?
dupl_df <- data.frame(name = c("A", "A", "B", "C", "C", "C", "D"),
GPA = c(3.5, 3.5, 4.0, 2.0, 3.0, 3.0, 2.0))
# Base R
duplicated(dupl_df$name)
# Duplicates in column "name" removed.
dupl_df[!duplicated(dupl_df$name),]
# Returns a vector, not data frame
dupl_df %>%
distinct(name) # Try adding .keep_all = TRUE argument
# Returns a data frame
dupl_df %>%
distinct(name, GPA)
# A character vector to split
onecol_df <- data.frame(labels = c('a1','b_2','c_3_2','d_4_1'))
# split the character at _
onecol_df %>% separate(col = "labels", sep = "_", into = c("alphabet", "numeric"))
# Read a subset of yelp data
my_yelp <- read_rds(here("Lab", "module_1", "week2", "yelp_all.geojson"))
my_yelp %>%
tibble() %>%
print(width = 1000)
yelp_flat <- my_yelp %>%
jsonlite::flatten() %>%
as_tibble() %>%
print(width = 1000)
yelp_flat
# Concatenate what's inside the list
yelp_concat <- yelp_flat %>%
mutate(transactions = transactions %>%
map_chr(., function(x) str_c(x, collapse=", ")),
location.display_address = location.display_address %>%
map_chr(., function(x) str_c(x, collapse=", ")))
# Custom function that takes the data frame in "categories" column in Yelp data
# and returns a character vector
concate_list <- function(x){
# x is a data frame with columns "alias" and "title" from Yelp$categories
# returns a character vector containing category concatenated titles
titles <- x[["title"]] %>% str_c(collapse = ", ")
return(titles)
}
yelp_flat2 <- yelp_concat %>%
mutate(categories = categories %>% map_chr(concate_list)) %>%
print(width = 1000)
yelp_flat2 %>% print(width = 1000)
# Dropping NA using is.na()
toy_df %>%
filter(!is.na(treatment_a))
# This check across all columns and drops all rows that have at least one NA.
toy_df %>%
drop_na()
# Issue 1 ------------------------------
# We don't seem to have this issue for Yelp data.
# Issue 2 ------------------------------
# Let's first check whether there are any NAs
my_yelp %>%
apply(., 2, function(x) sum(is.na(x)))
my_yelp$price
my_yelp %>%
distinct(id, .keep_all=T)
nrow(my_yelp)
# Issue 2 ------------------------------
# We do have many duplicated rows in our data, which is expected.
# Luckily, Yelp data provides a unique ID column for each business.
my_yelp %>%
distinct(id, name, review_count .keep_all=T)
my_yelp %>%
distinct(id, name, review_count, .keep_all=T)
my_yelp
yelp_subset <- my_yelp %>% select(categories, transactions, location.display_address)
yelp_subset <- my_yelp %>% select(id, categories, transactions, location.display_address)
yelp_subset <- my_yelp %>% select(id, categories, transactions, location.display_address) %>% slice(1:10)
write_rds(yelp_subset, here("Lab", "module_1", "week2", "yelp_all.geojson"))
yelp_subset <- read_rds(yelp_subset, here("Lab", "module_1", "week2", "yelp_all.geojson"))
yelp_subset <- read_rds(yelp_subset, here("Lab", "module_1", "week2", "yelp_all.geojson"))
yelp_subset <- read_rds(yelp_subset, here("Lab", "module_1", "week2", "yelp_all.geojson"))
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_all.geojson"))
yelp_subset %>%
tibble() %>%
print(width = 1000)
yelp_flat <- my_yelp %>%
jsonlite::flatten() %>%
as_tibble() %>%
print(width = 1000)
yelp_flat
yelp_flat <- yelp_subset %>%
jsonlite::flatten() %>%
as_tibble() %>%
print(width = 1000)
yelp_flat
yelp_flat
yelp_subset
knitr::opts_chunk$set(echo = TRUE)
tidycensus::census_api_key(Sys.getenv("census_api"))
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
tract %>% head() %>% knitr::kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
# Retaining only those I want.
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
# Function: Get tract-wise radius
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
epsg_id <- 4326 # Edit (9/8/2022): 4326 measures distance in meter. Before the edit, I used 26967.
r4all_loop <- vector("list", nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
# Appending X Y coordinates as seprate columns
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
tmap_mode('view')
# Select the first 10 rows
ready_4_yelp[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(tract[1:10,]) + tm_borders(col= 'blue')
# Function for formatting the url for API request
url_format <- function(latitude = NULL, longitude = NULL,
radius = NULL, categories = NULL, offset = NULL, limit = NULL){
# Parameters
base_url <- "https://api.yelp.com/v3/businesses/search?"
latitude <- paste0("latitude=", latitude)
longitude <- paste0("longitude=", longitude)
radius <- paste0("radius=", radius)
categories <- paste0("categories=", categories)
offset <- paste0("offset=", offset)
limit <- paste0("limit=", limit)
# Out
full_url <- paste0(c(base_url, latitude, longitude, radius, categories, offset, limit), collapse = "&")
return(full_url)
}
# Run url_format function
full_url <- url_format(latitude = 33.792479078196294, # This is Atlantic station
longitude = -84.39676077444938, # This is Atlantic station
radius=1000,
categories="restaurant",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
# Parse the body of the response (json format)
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed$businesses %>% head %>% kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
resp_raw <- content(resp, as = "raw")
resp_raw
which_tract <- 1
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'restaurant', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
# See what's inside
names(test)
# Business
paste0("is it a data.frame?: ", is.data.frame(test$businesses), ", ",
" how many rows?: ", nrow(test$businesses), ", ",
" how many columns?: ", ncol(test$businesses))
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0 when n = 1
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# out is where the results will be appended to.
out <- vector("list", required_n)
# Store the business information to nth slot in out
out[[n]] <- resp$businesses
# Change the name of the elements to the total required_n
# This is to know if there are more than 1000 businesses,
# we know how many.
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
# glue formats string by inserting {n} with what's currently stored in object n.
print(glue::glue("{n}th row has >= 1000 businesses."))
# Stop before going into the loop because we need to
# break down Census Tract to something smaller.
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
# Merge all elements in the list into a single data frame
out <- out %>% bind_rows()
return(out)
}
}
# Apply the function for the first Census Tract
yelp_first_tract <- get_yelp(ready_4_yelp[1,], "restaurant") %>%
as_tibble()
# Print
yelp_first_tract %>% print
yelp_first_tract
yelp_first_tract %>% map(class)
yelp_first_tract %>% selet(categories, coordinates, transactions, location) %>% slice(1:5)
yelp_first_tract %>% select(categories, coordinates, transactions, location) %>% slice(1:5) %>% write_rds(here("Lab", "module_1", "week2", "yelp_subset.csv"))
yelp_first_tract %>% select(categories, coordinates, transactions, location) %>% slice(1:5) %>% write_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset
yelp_subset$coordinates
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset %>%
tibble() %>%
print(width = 1000)
yelp_subset$coordinates$latitude
yelp_flat <- yelp_subset %>%
jsonlite::flatten() %>%
as_tibble() %>%
print(width = 1000)
yelp_flat
yelp_flat <- yelp_subset %>%
jsonlite::flatten() %>%
as_tibble() %>%
print(width = 1000)
yelp_flat
# Read the full data
my_yelp <- read_rds(here("Lab", "module_1", "week2", "yelp_all.geojson"))
# Issue 2 ------------------------------
# We do have many duplicated rows in our data, which is expected.
# Luckily, Yelp data provides a unique ID column for each business.
my_yelp %>%
distinct(id, .keep_all=T)
# Issue 2 ------------------------------
# We do have many duplicated rows in our data, which is expected.
# Luckily, Yelp data provides a unique ID column for each business.
yelp_unique <- my_yelp %>%
distinct(id, .keep_all=T)
# Read the full data
my_yelp <- read_rds(here("Lab", "module_2", "week2", "yelp_all.geojson"))
here("Lab", "module_1", "week2", "yelp_all.geojson")
# Read the full data
my_yelp <- st_read(here("Lab", "module_1", "week2", "yelp_all.geojson"))
yelp_all
ls()
# Prepare a collector
yelp_all_list <- vector("list", nrow(ready_4_yelp))
# Looping through all Census Tracts
for (row in 1:nrow(ready_4_yelp)){
yelp_all_list[[row]] <- suppressMessages(get_yelp(ready_4_yelp[row,], "restaurant"))
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
# Collapsing the list into a data.frame
yelp_all <- yelp_all_list %>% bind_rows() %>% as_tibble()
# print
yelp_all %>% print(width=1000)
yelp_all %>% write_rds(here("Lab", "module_1", "week2", "yelp_all.rds"))
yelp_all %>% select(categories, transactions, location) %>% slice(1:5) %>% write_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
# Read the full data
my_yelp <- read_rds(here("Lab", "module_1", "week2", "yelp_all.rds"))
yelp_unique <- my_yelp %>%
distinct(id, .keep_all=T)
paste0(nrow(my_yelp), "->", nrow(yelp_unique))
yelp_unique <- my_yelp %>%
distinct(id, .keep_all=T)
paste0(nrow(my_yelp), " -> ", nrow(yelp_unique)) %>% print()
my_yelp %>%
apply(., 2, function(x) sum(is.na(x)))
my_yelp
yelp_unique %>% map(sum(is.na()))
yelp_unique %>% map(~sum(is.na(.x)))
xaringan:::inf_mr()
library(tidyverse)
library(sf)
library(here)
library(tmap)
library(tidyverse) # tidyr is included in tidyverse package.
# Toy dataset
toy_df <- data.frame(name = c("John", "Jane", "Mary"),
treatment_a = c(NA, 16, 3),
treatment_b = c(2, 11, 1),
treatment_c = c(6, 12, NA))
print(toy_df)
# pivot longer
(toy_long <- toy_df %>%
pivot_longer(cols = treatment_a:treatment_c,
names_to = 'treatment', # new column name for 'cols' in character
values_to = 'result')) # new name for the column storing the values in character
# back to wider
(toy_wide <- toy_long %>%
pivot_wider(id_cols = name, # unique identifier
names_from = treatment, # from which columns should the new column names come?
values_from = result)) # from which columns should the values come?
dupl_df <- data.frame(name = c("A", "A", "B", "C", "C", "C", "D"),
GPA = c(3.5, 3.5, 4.0, 2.0, 3.0, 3.0, 2.0))
# Base R
duplicated(dupl_df$name)
# Duplicates in column "name" removed.
dupl_df[!duplicated(dupl_df$name),]
# Returns a vector, not data frame
dupl_df %>%
distinct(name) # Try adding .keep_all = TRUE argument
# Returns a data frame
dupl_df %>%
distinct(name, GPA)
# A character vector to split
onecol_df <- data.frame(labels = c('a1','b_2','c_3_2','d_4_1'))
# split the character at _
onecol_df %>% separate(col = "labels", sep = "_", into = c("alphabet", "numeric"))
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset %>%
tibble() %>%
print(width = 1000)
yelp_subset$coordinates
yelp_flat <- yelp_subset %>%
jsonlite::flatten() %>%
as_tibble() %>%
print(width = 1000)
yelp_flat$coordinates.latitude
# Concatenate what's inside the list
yelp_concat <- yelp_flat %>%
mutate(transactions = transactions %>%
map_chr(., function(x) str_c(x, collapse=", ")),
location.display_address = location.display_address %>%
map_chr(., function(x) str_c(x, collapse=", ")))
# Custom function that takes the data frame in "categories" column in Yelp data
# and returns a character vector
concate_list <- function(x){
# x is a data frame with columns "alias" and "title" from Yelp$categories
# returns a character vector containing category concatenated titles
titles <- x[["title"]] %>% str_c(collapse = ", ")
return(titles)
}
yelp_flat2 <- yelp_concat %>%
mutate(categories = categories %>% map_chr(concate_list)) %>%
print(width = 1000)
yelp_flat2 %>% print(width = 1000)
# Dropping NA using is.na()
toy_df %>%
filter(!is.na(treatment_a))
# This check across all columns and drops all rows that have at least one NA.
toy_df %>%
drop_na()
my_yelp <- read_rds(here("Lab", "module_1", "week2", "yelp_all.rds"))
# Issue 1 ------------------------------
# We don't seem to have this issue for Yelp data.
# Issue 2 ------------------------------
# We do have many duplicated rows in our data, which is expected.
# Luckily, Yelp data provides a unique ID column for each business.
yelp_unique <- my_yelp %>%
distinct(id, .keep_all=T)
paste0(nrow(my_yelp), " -> ", nrow(yelp_unique)) %>% print()
yelp_flat %>% head()
yelp_unique <- my_yelp %>%
distinct(id, .keep_all=T)
yelp_unique
yelp_flat <- yelp_unique %>%
# 1. Flattening columns with data frame
jsonlite::flatten()
yelp_flat
yelp_flat %>% head()
yelp_flat <- yelp_unique %>%
# 1. Flattening columns with data frame
jsonlite::flatten() %>%
# 2. Handling list-columns
mutate(transactions = transactions %>%
map_chr(., function(x) str_c(x, collapse=", ")),
location.display_address = location.display_address %>%
map_chr(., function(x) str_c(x, collapse=", ")),
categories = categories %>% map_chr(concate_list)) # concate_list is the custom function
yelp_flat %>% tibble
yelp_flat %>% tibble %>% print(width = 1000)
yelp_flat %>%
map(., function(x) sum(is.na(x)))
# Issue 4 ------------------------------
# Let's first check whether there are any NAs.
yelp_flat %>%
map_dbl(., function(x) sum(is.na(x)))
