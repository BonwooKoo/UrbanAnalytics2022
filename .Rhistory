addLegend(position = "bottomright",
values = stop_tract$sum_n_departures,
pal = sum_n_depart)
sum_depart_map
message(str_c("there are ", sum(is.na(stop_tract$sum_n_departures)), " NAs in n_departures"))
# Is there any correlation between SES and service area?
stop_tract_plot <- stop_tract %>%
mutate(hhinc = log(hhinc),
pct_novhc = log(pct_novhc + 0.05),
n_departure_log = log(sum_n_departures + 1)) %>%
pivot_longer(cols = c('hhinc', 'pct_wh', 'pct_bl', 'pct_novhc', "r_tot", "ln_pop_den"),
names_to = "variable", values_to = "value") %>%
mutate(variable = factor(variable, labels = c('Household Income', "Population Density", "% Black",
"% No car", "% White", "Total Population")))
departure_count <- stop_tract_plot %>%
ggplot(aes(x = n_departure_log, y = value)) +
geom_point(alpha = 0.2) +
geom_smooth(method = "lm") +
facet_wrap(~variable, scales = "free_y") +
labs(x = "Count of departures between 7AM and 10AM", title = "Departure Count VS. Socio-demographics") +
theme_bw()
plotly::ggplotly(departure_count)
# Step 1:
stop_dist <- stop_group_distances(atlsf$stops, by='stop_name') %>%
# Step 2:
filter(dist_max > 200)
# Step 3
atl$stops <- atl$stops %>%
group_by(stop_name) %>%
mutate(stop_name = case_when(stop_name %in% stop_dist$stop_name ~ paste0(stop_name, " (", seq(1,n()), ")"),
TRUE ~ stop_name))
# Step 4
atl$transfers <- gtfsrouter::gtfs_transfer_table(atl,
d_limit = 200,
min_transfer_time = 120)
# Step 5
am_stop_time <- filter_stop_times(gtfs_obj = atl,
extract_date = "2021-08-14",
min_departure_time = 3600*7, # input unit is in second. So 3500*7 is 7AM
max_arrival_time = 3600*10)  # similarly, this is 10AM
# travel_times
trvt <- travel_times(filtered_stop_times = am_stop_time,
stop_name = "MIDTOWN STATION",
return_coords = TRUE)
# ..and visualize the output
trvt_pal <- colorQuantile(palette = "Reds", domain = trvt$travel_time)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircles(data = trvt %>% st_as_sf(coords = c("to_stop_lon", "to_stop_lat"), crs = 4326), # converting trvt into sf object on the fly.
fillColor = ~trvt_pal(travel_time), # Define color
stroke = F, # Turn off the outer border lines of circles
radius = 300, # Size of the circle
fillOpacity = 0.7, # Transparency
popup = paste0("Travel Time from <br> <strong> MIDTOWN: ", round(trvt$travel_time/60, 2), " minutes <strong>") %>% # Defines what's displayed on popup
lapply(htmltools::HTML))
# Import required packages
library(tidytransit)
library(tidyverse)
library(tmap)
library(ggplot2)
library(here)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(plotly)
library(tidygraph)
library(leafsync)
library(here)
# This GTFS file is downloaded from
# https://opendata.atlantaregional.com/datasets/marta-gtfs-latest-feed/about
atl <- read_gtfs(here("Lab", "module_2", 'MARTA_GTFS_Latest_Feed.zip'))
typeof(atl)
names(atl)
print(head(atl))
# Converting GTFS data into sf objects
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
atlsf$stops %>% head() # Notice that this is POINT
atlsf$shapes %>% head() # This is LINESTRING
# Visualize
a <- leaflet(atlsf$shapes) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addPolylines(weight = 1, color = "red") %>% # add lines
addControl(htmltools::HTML("Route shapes")) # add Title
b <- leaflet(atlsf$stops) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addCircles(weight = 3, color = "red") %>% # add circles
addControl(htmltools::HTML("Stop shapes")) # add Title
leafsync::sync(a,b)
# Join routes table with trips table with shapes table
trip_routes <- atl$trips %>%
full_join(atl$routes, by = "route_id")
trip_shape <- atlsf$shapes %>%
full_join(atl$trips %>%
select(shape_id, trip_id),
by = "shape_id")
# Merging the two into one and then taking only one row for each
# unique combination of route_id and shape_id.
route_trip_shape <- trip_shape %>%
select(-shape_id) %>%
full_join(trip_routes, by = c("trip_id")) %>%
group_by(shape_id, route_id) %>%
slice(1)
# Route type is not really intuitive - let's fix that
route.shape <- route_trip_shape %>%
mutate(route_type = case_when(
route_type == "0" ~ 'Tram, Streetcar',
route_type == "1" ~ 'Subway, Metro',
route_type == "2" ~ 'Rail',
route_type == "3" ~ 'Bus'
))
pal <- leaflet::colorFactor(c("red", "orange", "pink"), domain = route.shape$route_type)
route.shape %>%
leaflet::leaflet(data = .) %>%
leaflet::addProviderTiles(providers$CartoDB.DarkMatter) %>%
leaflet::addPolylines(color = ~pal(route_type),
weight = 3,
opacity = 0.9,
popup = paste0("Route type: ", route.shape$route_type))
# If we do not convert CRS to a projected one, the buffer may generate a ragged boundaries.
# https://r-spatial.github.io/sf/articles/sf7.html#buffers-1
# https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry
# Buffering LINESTRING ---------------------------------------
sf::sf_use_s2(TRUE) # This is default to TRUE when we load SF package. So this code is not really needed. I added it here just to make it more explicit.
MARTA_buffer <- route.shape %>%
sf::st_transform(crs = 26967) %>%
sf::st_buffer(dist = units::set_units(400, "m"))
# To union the buffer polygons by route_type
MARTA_buffer_group <- MARTA_buffer %>%
group_by(route_type) %>%
summarise()
# Buffering POINTS ---------------------------------------
# Just to show that lines & points overlap well
MARTA_stop_buffer <- atlsf$stops %>%
st_transform(crs = 26967) %>%
st_buffer(dist = units::set_units(400, "m")) %>%
st_union()
pal <- colorFactor(palette = c("red", "yellow", "blue"), domain = MARTA_buffer_group$route_type)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = MARTA_buffer_group %>% st_transform(crs = 4326), col = ~pal(route_type),
popup = MARTA_buffer_group$route_type,
group = "Buffer from Line") %>%
addPolygons(data = MARTA_stop_buffer %>% st_transform(crs = 4326),
weight = 0.5,
color = "white",
group = "Buffer from Point") %>%
addLayersControl(
overlayGroups = c("Buffer from Line", "Buffer from Point"),
options = layersControlOptions(collapsed = FALSE)
)
# Your API key
tidycensus::census_api_key(Sys.getenv('census_api'))
# Get American Community Survey
acs2020 <- tidycensus::get_acs(geography = "tract",
variables = c("hhinc" = 'B19013_001',
"r_tot" = "B02001_001",
"r_wh" = "B02001_002",
"r_bl" = "B02001_003",
"tot_hh" = "B25044_001",
"own_novhc" = "B25044_003",
"rent_novhc" = "B25044_010"),
year = 2020,
output = "wide",
state = "GA",
county = c("Fulton", "DeKalb", "Clayton"),
geometry = TRUE)
# Cleaning Census data
acs2020c <- acs2020 %>%
select(GEOID,
hhinc = hhincE,
r_tot = r_totE,
r_wh = r_whE,
r_bl = r_blE,
tot_hh = tot_hhE,
own_novhc = own_novhcE,
rent_novhc = rent_novhcE) %>%
mutate(pct_wh = r_wh / r_tot,
pct_bl = r_bl / r_tot,
pct_novhc = (own_novhc + rent_novhc)/tot_hh) %>%
# Calculate area of the Census Tract polygons
mutate(area = st_area(.) %>% unclass) %>%
mutate(ln_pop_den = log((r_tot / (area/1000^2)) + 1)) %>%
filter(!is.na(hhinc), !is.na(r_tot), !is.na(own_novhc))
pal1 <- colorNumeric(palette = "YlOrRd", domain = acs2020c$hhinc)
pal2 <- colorFactor("Spectral", domain = MARTA_buffer_group$route_type)
# Mapping
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(group = "ACS",
data = acs2020c,
color = "grey",
fillColor = ~pal1(hhinc),
fillOpacity = 0.5,
weight = 1,
popup = leafpop::popupTable(round(st_drop_geometry(acs2020c[,c("hhinc", "pct_wh", "pct_bl")]),2))) %>%
addPolygons(group = "MARTA",
data = MARTA_buffer_group %>%
st_transform(crs = st_crs(acs2020c)),
color = ~pal2(route_type),
weight = 1,
opacity = 0.9) %>%
addLayersControl(
overlayGroups = c("ACS", "MARTA"),
options = layersControlOptions(collapsed = FALSE)
)
knitr::include_graphics("http://postgis.net/workshops/postgis-intro/_images/intersection.jpg")
# Intersect buffer with tract
buffer_intersect_tract <- acs2020c %>%
# Unify the CRS
st_transform(crs = st_crs(MARTA_buffer_group)) %>%
# Intersection
st_intersection(MARTA_buffer_group) %>%
# Extract bus routes only
filter(route_type == "Bus")
# Visualize
pal_buf <- colorFactor(palette = "Spectral", domain = buffer_intersect_tract$route_type)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = acs2020c %>% st_transform(crs = 4326), fillOpacity = 0.2, color = "white", weight = 0.5, group = 'Census') %>%
addPolygons(data = MARTA_buffer_group %>% st_transform(crs = 4326), fillOpacity = 0.2, color = "yellow", weight  = 0.5, group = 'GTFS') %>%
addPolygons(data = buffer_intersect_tract %>% st_transform(crs = 4326), group = "Intersection",
fillColor = ~pal_buf(route_type), fillOpacity = 0.9, weight = 1, opacity = 0.3, color = "grey") %>%     # leaflet takes 4326
addLayersControl(overlayGroups = c("Census", "GTFS", "Intersection"), options = layersControlOptions(collapsed = FALSE))
# Area of intersected area
buffer_intersect_tract2 <- buffer_intersect_tract %>%
mutate(subarea = unclass(st_area(.)),
pct_served = subarea/area) %>%
# Back to WGS84
st_transform(crs = 4326)
# Joining the intersected information back to the original Census Data.
# This is needed because we may have lost a few polygons during intersection.
buffer_by_tract <- acs2020c %>%
# In left_join(A, B), B must be non-sf object.
left_join(buffer_intersect_tract2 %>%
select(GEOID, pct_served) %>%
st_set_geometry(NULL),
by = "GEOID") %>%
# There are many NAs in the pct_served column because there are many Census Tracts
# that do not overlap with the GTFS buffer. They would have NA in pct_served column.
# This code converts the NAs into 0.
mutate(pct_served = case_when(is.na(pct_served) ~ 0,
TRUE ~ pct_served))
# Map it!
pal_serv <- colorNumeric(palette = "Spectral", domain = buffer_by_tract$pct_served, reverse = TRUE)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = buffer_by_tract,
fillColor = ~pal_serv(pct_served), fillOpacity = 0.9,
color = "white", opacity = 0.2,
weight = 1) %>%
addLegend("bottomright",
pal = pal_serv,
values = buffer_by_tract$pct_served,
title = "% Area within 400m from transit line")
# Readable plot title
var_name <- c(
'hhinc'="Annual Household Income",
'pct_bl'="% Black population",
'pct_novhc'="% Household without vehicle",
'pct_wh'="% White population",
'r_tot'="Total population",
'ln_pop_den' = "(log) Population density"
)
var_name_labeller <-  as_labeller(var_name)
buffer_by_tract %>%
#filter(na_index) %>%
pivot_longer(cols = c('hhinc', 'pct_wh', 'pct_bl', 'pct_novhc', "r_tot", "ln_pop_den"), names_to = "variable", values_to = "value") %>%
ggplot(aes(x = pct_served, y = value)) +
facet_wrap(~variable, scales = "free_y", labeller = var_name_labeller) +
geom_point(alpha = 0.4) +
geom_smooth(method = "lm", se = FALSE, color="red") +
labs(x = "\n % Area with 400m beffer from transit line") +
theme_bw()
## Correlation analysis for just two variables
# Syntax 1: not using pipe
cor.test(buffer_by_tract$pct_served,
buffer_by_tract$hhinc)
# Syntax 2: using pipe, useful when you want to do
# something first and then do correlation with the result
buffer_by_tract %>%
with(cor.test(pct_served, hhinc)) # (you can use whichever syntax you prefer).
## Correlation analysis for multiple variables
# Define a vector with the variable names that you want to evaluate
test_var <- c("hhinc", "pct_bl", "pct_wh", "pct_novhc", "r_tot", "ln_pop_den")
# Custom function that runs correlation analysis
# This function takes one vector as input (because the other vector is pct_served in our case)
# and outputs a character string that summarizes correlation analysis results
map_cor <- function(x){
cor.object <- cor.test(buffer_by_tract[['pct_served']],
buffer_by_tract[[x]])
df <- cor.object$parameter
r <- round(cor.object$estimate,3)
t <- round(cor.object$statistic,3)
p <- round(cor.object$p.value,3)
return(glue::glue("Between pct_served and {var_name[x]}: r({df})={r} (t={t}, p={p})"))
}
# Apply custom function to test_var
map_chr(test_var, map_cor)
service_ids <- atl$calendar %>% pull(service_id)
stop_freq <- get_stop_frequency(atl, start_time = 3600*7, end_time = 10*3600, service_ids = service_ids, by_route = T)
stop_freq_sf <- atlsf$stops %>%
left_join(stop_freq, by="stop_id") %>%
filter(!is.na(n_departures))
freq_pal <- colorNumeric("Reds", stop_freq_sf$n_departures)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircles(data = stop_freq_sf,
fillColor = freq_pal(stop_freq_sf$n_departures),
fillOpacity = 0.8,
weight = 10,
stroke = FALSE,
popup = str_c(stop_freq_sf$stop_name, ": ", stop_freq_sf$n_departures)) %>%
addLegend(position = "bottomright",
pal = freq_pal,
values = stop_freq_sf$n_departures,
title = "Count of Departures <br> between 7AM and 10AM")
stop_tract <- acs2020c %>%
st_transform(crs = 4326) %>%
st_join(stop_freq_sf) %>%
group_by(GEOID) %>%
summarise(avg_n_departures = mean(n_departures),
sum_n_departures = sum(n_departures),
hhinc = mean(hhinc),
r_tot = mean(r_tot),
pct_wh = mean(pct_wh),
pct_bl = mean(pct_bl),
pct_novhc = mean(pct_novhc),
r_tot = mean(r_tot),
ln_pop_den = mean(ln_pop_den))
knitr::kable(head(stop_tract))
sum_n_depart <- colorQuantile(palette = "Reds", domain = stop_tract$sum_n_departures)
sum_depart_map <- leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = stop_tract,
fillColor = sum_n_depart(stop_tract$sum_n_departures),
fillOpacity = 0.8,
color = 'grey',
weight = 1,
popup = paste0("ID: ", stop_tract$GEOID, ", Value: ", stop_tract$sum_n_departures)) %>%
addLegend(position = "bottomright",
values = stop_tract$sum_n_departures,
pal = sum_n_depart)
sum_depart_map
message(str_c("there are ", sum(is.na(stop_tract$sum_n_departures)), " NAs in n_departures"))
# Is there any correlation between SES and service area?
stop_tract_plot <- stop_tract %>%
mutate(hhinc = log(hhinc),
pct_novhc = log(pct_novhc + 0.05),
n_departure_log = log(sum_n_departures + 1)) %>%
pivot_longer(cols = c('hhinc', 'pct_wh', 'pct_bl', 'pct_novhc', "r_tot", "ln_pop_den"),
names_to = "variable", values_to = "value") %>%
mutate(variable = factor(variable, labels = c('Household Income', "Population Density", "% Black",
"% No car", "% White", "Total Population")))
departure_count <- stop_tract_plot %>%
ggplot(aes(x = n_departure_log, y = value)) +
geom_point(alpha = 0.2) +
geom_smooth(method = "lm") +
facet_wrap(~variable, scales = "free_y") +
labs(x = "Count of departures between 7AM and 10AM", title = "Departure Count VS. Socio-demographics") +
theme_bw()
plotly::ggplotly(departure_count)
# Step 1:
stop_dist <- stop_group_distances(atlsf$stops, by='stop_name') %>%
# Step 2:
filter(dist_max > 200)
# Step 3
atl$stops <- atl$stops %>%
group_by(stop_name) %>%
mutate(stop_name = case_when(stop_name %in% stop_dist$stop_name ~ paste0(stop_name, " (", seq(1,n()), ")"),
TRUE ~ stop_name))
# Step 4
atl$transfers <- gtfsrouter::gtfs_transfer_table(atl,
d_limit = 200,
min_transfer_time = 120)
# Step 5
am_stop_time <- filter_stop_times(gtfs_obj = atl,
extract_date = "2021-08-14",
min_departure_time = 3600*7, # input unit is in second. So 3500*7 is 7AM
max_arrival_time = 3600*10)  # similarly, this is 10AM
# travel_times
trvt <- travel_times(filtered_stop_times = am_stop_time,
stop_name = "MIDTOWN STATION",
return_coords = TRUE)
# ..and visualize the output
trvt_pal <- colorQuantile(palette = "Reds", domain = trvt$travel_time)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircles(data = trvt %>% st_as_sf(coords = c("to_stop_lon", "to_stop_lat"), crs = 4326), # converting trvt into sf object on the fly.
fillColor = ~trvt_pal(travel_time), # Define color
stroke = F, # Turn off the outer border lines of circles
radius = 300, # Size of the circle
fillOpacity = 0.7, # Transparency
popup = paste0("Travel Time from <br> <strong> MIDTOWN: ", round(trvt$travel_time/60, 2), " minutes <strong>") %>% # Defines what's displayed on popup
lapply(htmltools::HTML))
# Import required packages
library(tidyverse)
library(tmap)
library(ggplot2)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(leafsync)
library(dbscan)
library(sfnetworks)
library(tigris)
library(tidygraph)
library(plotly)
library(osmdata)
# Get bounding box coordinates for Atlanta
bb <- getbb('Atlanta, GA')
# Converting bb into an sf object
bb_sf <- bb %>% t %>% data.frame() %>%
st_as_sf(coords = c("x", "y"), crs = 4326) %>%
st_bbox() %>%
st_as_sfc()
## Plot--
tmap_mode('view')
tm_shape(bb_sf) + tm_borders()
# Get OSM road data
osm_road <- opq(bbox = bb) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
names(osm_road)
## Plot--
tmap_mode('plot')
tm_shape(osm_road$osm_lines) + tm_lines(col = "highway")
# Breakdown of highway types
round( prop.table(table(osm_road$osm_lines$highway)) * 100, 1 )
# p1 is lower left corner, p2 is the upper right corner
p1 <- c(33.746217847959734, -84.40851957882589)
p2 <- c(33.785889694219634, -84.36354430149285)
# Custom BB
my_bb <- matrix(c(p1[2], p1[1],
p2[2], p2[1]), ncol = 2)
colnames(my_bb) <- c("min", "max")
rownames(my_bb) <- c("x", "y")
# Custom BB to sf
my_bb_sf <- my_bb %>% t %>% data.frame() %>%
st_as_sf(coords = c("x", "y"), crs = 4326) %>%
st_bbox() %>%
st_as_sfc()
# Extract a smaller network for exercise purpose
osm_small <- osm_road$osm_lines[my_bb_sf,]
## Plot--
tmap_mode('view')
tm_shape(bb_sf) + tm_borders(col = "black") +  # Black = larger bbox
tm_shape(my_bb_sf) + tm_borders(col = "red") +  # Red = smaller bbox
tm_shape(osm_small$osm_lines) + tm_lines(col = "black") # Black line = small network
osm_small
osm_small
osm_road
str(osm_road)
osm_road
osm_road$bbox
is.list(osm_road)
is.data.frame(osm_road)
osm_road
osm_road$osm_points
osm_road$osm_lines
leaflet %>% addProviderTiles(providers$CartoDB.DarkMatter) %>% addCircles(data = osm_road$osm_points)
osm_road$osm_points
leaflet %>% addProviderTiles(providers$CartoDB.DarkMatter) %>% addCircles(data = osm_road$osm_points)
leaflet() %>% addProviderTiles(providers$CartoDB.DarkMatter) %>% addCircles(data = osm_road$osm_points)
osm_road$osm_points %>% names()
osm_road$osm_points
osm_road$osm_multilines
osm_road$osm_polygons
osm_road <- opq(bbox = bb) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
osm_road$osm_lines
# Custom BB
my_bb <- matrix(c(p1[2], p1[1],
p2[2], p2[1]), ncol = 2)
colnames(my_bb) <- c("min", "max")
rownames(my_bb) <- c("x", "y")
# Custom BB to sf
my_bb_sf <- my_bb %>% t %>% data.frame() %>%
st_as_sf(coords = c("x", "y"), crs = 4326) %>%
st_bbox() %>%
st_as_sfc()
# Extract a smaller network for exercise purpose
osm_small <- osm_road$osm_lines[my_bb_sf,]
## Plot--
tmap_mode('view')
tm_shape(bb_sf) + tm_borders(col = "black") +  # Black = larger bbox
tm_shape(my_bb_sf) + tm_borders(col = "red") +  # Red = smaller bbox
tm_shape(osm_small) + tm_lines(col = "black") # Black line = small network
net <- sfnetworks::as_sfnetwork(osm_small, directed = FALSE)
net
net$node
net[['note']]
net[['node']]
str(net)
?as_sfnetwork
net
net %>% activate('nodes')
net %>% activate('nodes') %>% print(n=10)
net %>% activate('nodes')
osm_small
net <- sfnetworks::as_sfnetwork(osm_small, directed = FALSE)
print(net)
