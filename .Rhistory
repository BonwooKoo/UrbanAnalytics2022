census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
names_sep = "([a-z])([A-Z])",
values_to = c("estimate","sdf"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable", "asdf"),
names_sep = "([a-z])([A-Z])",
values_to = c("estimate","sdf"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable", "asdf"),
names_sep = "([a-z])([A-Z])",
values_to = c("estimate"))
census_wide
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("estimate"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(variable = stringr::str_extract(variable, "[a-z]"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(variable = stringr::str_extract(variable, "[a-z]*"))
suffix = stringr::str_extract(variable, "[A-Z]*")
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
census_wide %>%
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z]*")
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z]*"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z]*"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[E|M]"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z]"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z]*"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z*]"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z*]"),
suffix = stringr::str_extract(variable, "[A-Z*]"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z*]"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]*"),
suffix = stringr::str_extract(variable, "[A-Z]+"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]+"),
suffix = stringr::str_extract(variable, "[A-Z]+"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]"),
suffix = stringr::str_extract(variable, "[A-Z]+"))
+
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]+"),
suffix = stringr::str_extract(variable, "[A-Z]+"))
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM,
names_to = c("variable"),
values_to = c("value")) %>%
mutate(measure = stringr::str_extract(variable, "[a-z]+"),
suffix = stringr::str_extract(variable, "[A-Z]+"))
300*1*60*60*24
300*1*60*60*24*0.001
300*1*60*60*24*1e-6
census_wide %>%
pivot_longer(cols = hhincomeE:race.totM, # Cols to be affected
names_to = c("variable"), #
values_to = c("value"))
?pivot_wider
longer
longer <- census_wide %>%
pivot_longer(cols = hhincomeE:race.totM, # Cols to be affected
names_to = c("variable"), # Name for the label column
values_to = c("value")) # Name for the value column
longer
wider <- census_long %>%
pivot_wider(id_cols = c(GEOID, NAME),
names_from = c("variable"),
values_from = c("value"))
wider <- longer %>%
pivot_wider(id_cols = c(GEOID, NAME),
names_from = c("variable"),
values_from = c("value"))
wider
tfruns::training_run("D:/Dropbox (GaTech)/Work/Working/School/UA_2022/external/Lab/module_1/week2/Module1_Tidy_Yelp_Slide.Rmd")
xaringan:::inf_mr()
library(tidyverse)
library(sf)
library(here)
library(tmap)
library(tidyverse) # tidyr is included in tidyverse package.
# Toy dataset
toy_df <- data.frame(name = c("John", "Jane", "Mary"),
treatment_a = c(NA, 16, 3),
treatment_b = c(2, 11, 1),
treatment_c = c(6, 12, NA))
print(toy_df)
# pivot longer
(toy_long <- toy_df %>%
pivot_longer(cols = treatment_a:treatment_c,
names_to = 'treatment', # new column name for 'cols' in character
values_to = 'result')) # new name for the column storing the values in character
# back to wider
(toy_wide <- toy_long %>%
pivot_wider(id_cols = name, # unique identifier
names_from = treatment, # from which columns should the new column names come?
values_from = result)) # from which columns should the values come?
dupl_df <- data.frame(name = c("A", "A", "B", "C", "C", "C", "D"),
GPA = c(3.5, 3.5, 4.0, 2.0, 3.0, 3.0, 2.0))
# Base R
duplicated(dupl_df$name)
# Duplicates in column "name" removed.
dupl_df[!duplicated(dupl_df$name),]
# Returns a vector, not data frame
dupl_df %>%
distinct(name) # Try adding .keep_all = TRUE argument
# Returns a data frame
dupl_df %>%
distinct(name, GPA)
read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
# Read a subset of Yelp data we downloaded last week
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset %>% save("C:/users/bonwo/Downloads/subset.txt")
yelp_subset %>% save(file="C:/users/bonwo/Downloads/test.txt")
load("C:/users/bonwo/Downloads/test.txt")
rm(list= ls())
load("C:/users/bonwo/Downloads/test.txt")
ls()
a <- load("C:/users/bonwo/Downloads/test.txt")
a
a <- load("C:/users/bonwo/Downloads/test.RData")
yelp_subset %>% save("C:/users/bonwo/Downloads/test.RData")
yelp_subset %>% save(file="C:/users/bonwo/Downloads/test.RData")
# Read a subset of Yelp data we downloaded last week
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset %>% save(file="C:/users/bonwo/Downloads/test.RData")
rm(list=ls())
load("C:/users/bonwo/Downloads/test.RData")
ls()
a <- load("C:/users/bonwo/Downloads/test.RData")
a
# Read a subset of Yelp data we downloaded last week
yelp_subset <- read_rds(here("Lab", "module_1", "week2", "yelp_subset.rds"))
yelp_subset
yelp_subset %>% save(file="C:/users/bonwo/Downloads/test.RData")
a <- load(file="C:/users/bonwo/Downloads/test.RData")
a
yelp_subset
load(file="C:/users/bonwo/Downloads/test.Rdata")
ls()
rm(list=ls())
load(file="C:/users/bonwo/Downloads/test.Rdata")
ls()
load(file="C:/users/bonwo/Downloads/test.Rdata")
ls()
knitr::opts_chunk$set(echo = TRUE)
tidycensus::census_api_key(Sys.getenv("census_api"))
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
tract %>% head() %>% knitr::kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
# Retaining only those I want.
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
# Function: Get tract-wise radius
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
epsg_id <- 4326 # Edit (9/8/2022): 4326 measures distance in meter. Before the edit, I used 26967.
r4all_loop <- vector("list", nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
# Appending X Y coordinates as seprate columns
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
tmap_mode('view')
# Select the first 10 rows
ready_4_yelp[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(tract[1:10,]) + tm_borders(col= 'blue')
# Function for formatting the url for API request
url_format <- function(latitude = NULL, longitude = NULL,
radius = NULL, categories = NULL, offset = NULL, limit = NULL){
# Parameters
base_url <- "https://api.yelp.com/v3/businesses/search?"
latitude <- paste0("latitude=", latitude)
longitude <- paste0("longitude=", longitude)
radius <- paste0("radius=", radius)
categories <- paste0("categories=", categories)
offset <- paste0("offset=", offset)
limit <- paste0("limit=", limit)
# Out
full_url <- paste0(c(base_url, latitude, longitude, radius, categories, offset, limit), collapse = "&")
return(full_url)
}
# Run url_format function
full_url <- url_format(latitude = 33.792479078196294, # This is Atlantic station
longitude = -84.39676077444938, # This is Atlantic station
radius=1000,
categories="restaurant",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
# Parse the body of the response (json format)
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed$businesses %>% head %>% kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
resp_raw <- content(resp, as = "raw")
resp_raw
test_h <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'hotel', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
which_tract <- 1
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'hotel', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
?business_search
# Run url_format function
full_url <- url_format(latitude = 33.792479078196294, # This is Atlantic station
longitude = -84.39676077444938, # This is Atlantic station
radius=1000,
categories="hotel",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed$businesses %>% head %>% kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
resp_parsed
ready_4_yelp$y[which_tract]
ready_4_yelp$x[which_tract]
test_1
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'grocery', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test_1
rm(test_1)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'grocery', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
ready_4_yelp$y[which_tract]
# Run url_format function
full_url <- url_format(latitude = ready_4_yelp$y[which_tract], # This is Atlantic station
longitude = ready_4_yelp$x[which_tract], # This is Atlantic station
radius=round(ready_4_yelp$radius[which_tract]),
categories="restaurant",
offset = 0,
limit = 50)
# Run url_format function
full_url <- url_format(latitude = ready_4_yelp$y[which_tract], # This is Atlantic station
longitude = ready_4_yelp$x[which_tract], # This is Atlantic station
radius=round(ready_4_yelp$radius[which_tract]),
categories="hotel",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
# Parse the body of the response (json format)
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
resp_parsed
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'grocery', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'hotel', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'shopping', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'shopping', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'hotels', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'hair', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'arts', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'Restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'restaurant', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
# categories = 'restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
