library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
# Download data from Census 2020 - here we are downloading income, race, and means of transportation to work
FD_tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = "B02001_003",
trans.total = "B08006_001",
trans.car = "B08006_002",
trans.drovealone = "B08006_003",
trans.carpooled = "B08006_004", # Notice that I was not interested in 005-007 (2 person/ 4 person carpool etc.)
trans.pubtrans = "B08006_008", # Did not want to download any details about the type of public transport (009-0013)
trans.bicycle = "B08006_014",
trans.walk = "B08006_015",
trans.WfH = "B08006_017"
),
year = 2020,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# The data contains several redundant columns that we will not use. So, let's subset the data to only have the columns we will use
FD_tract <- FD_tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE,
trans.total = trans.totalE,
trans.car = trans.carE,
trans.drovealone = trans.drovealoneE,
trans.carpooled = trans.carpooledE,
trans.pubtrans = trans.pubtransE,
trans.bicycle = trans.bicycleE,
trans.walk = trans.walkE,
trans.WfH = trans.WfHE)
tmap_mode("view")
## tmap mode set to interactive viewing
tm_shape(FD_tract) + tm_borders()
# Function: Get tract-wise radius
epsg_id <- 4326
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
# Using a functional -----------------------------------------------------------
# We use a functional (lapply) to apply this custom function to each Census Tract.
r4all_apply <- FD_tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
# Select the first 10 rows
ready_4_yelp[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(FD_tract[1:10,]) + tm_borders(col= 'blue')
## =========================================================================
## Starting Yelp API call and data capture process
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0 when n = 1
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# out is where the results will be appended to.
out <- vector("list", required_n)
# Store the business information to nth slot in out
out[[n]] <- resp$businesses
# Change the name of the elements to the total required_n
# This is to know if there are more than 1000 businesses,
# we know how many.
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
# glue formats string by inserting {n} with what's currently stored in object n.
print(glue::glue("{n}th row has >= 1000 businesses."))
# Stop before going into the loop because we need to
# break down Census Tract to something smaller.
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
# Merge all elements in the list into a single data frame
out <- out %>% bind_rows()
return(out)
}
}
# Get data for the first tract
yelp_first_tract <- get_yelp(ready_4_yelp[1,], "yoga") %>%
as_tibble()
# Prepare a collector
yelp_all_list <- vector("list", nrow(ready_4_yelp))
# Looping through all Census Tracts
for (row in 1:nrow(ready_4_yelp)){
yelp_all_list[[row]] <- suppressMessages(get_yelp(ready_4_yelp[row,], "yoga"))
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
# Import required packages
library(tidytransit)
library(tidyverse)
library(tmap)
library(ggplot2)
# library(gtfsrouter)
library(here)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(plotly)
# library(igraph)
library(tidygraph)
# library(dodgr)
library(leafsync)
# source("https://raw.githubusercontent.com/BonwooKoo/gtfs_to_igraph/master/gtfs_to_igraph.R")
wd <- file.path(Sys.getenv('setwd'),"work/working/School/UA_2022/external/Lab/module_2")
setwd(eval(wd))
# This GTFS file is downloaded from
# https://opendata.atlantaregional.com/datasets/marta-gtfs-latest-feed/about
atl <- read_gtfs('MARTA_GTFS_Latest_Feed.zip')
typeof(atl)
names(atl)
print(head(atl))
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
head(atlsf)
a <- leaflet(atlsf$shapes) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addPolylines(weight = 1, color = "red") %>% # add lines
addControl(htmltools::HTML("Route shapes")) # add Title
b <- leaflet(atlsf$stops) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addCircles(weight = 3, color = "red") %>% # add lines
addControl(htmltools::HTML("Stop shapes")) # add Title
leafsync::sync(a,b)
# Step 1:
stop_dist <- stop_group_distances(atlsf$stops, by='stop_name') %>%
# Step 2:
filter(dist_max > 200)
# Step 3
atl$stops <- atl$stops %>%
group_by(stop_name) %>%
mutate(stop_name = case_when(stop_name %in% stop_dist$stop_name ~ paste0(stop_name, " (", seq(1,n()), ")"),
TRUE ~ stop_name))
# Step 4
atl$transfers <- gtfsrouter::gtfs_transfer_table(atl,
d_limit = 200,
min_transfer_time = 120)
# Step 5
am_stop_time <- filter_stop_times(gtfs_obj = atl,
extract_date = "2021-08-14",
min_departure_time = 3600*7, # input unit is in second. So 3500*7 is 7AM
max_arrival_time = 3600*10)  # similarly, this is 10AM
# travel_times
trvt <- travel_times(filtered_stop_times = am_stop_time,
stop_name = "MIDTOWN STATION",
return_coords = TRUE)
# ..and visualize the output
trvt_pal <- colorQuantile(palette = "Reds", domain = trvt$travel_time)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircles(data = trvt %>% st_as_sf(coords = c("to_stop_lon", "to_stop_lat"), crs = 4326), # converting trvt into sf object on the fly.
fillColor = ~trvt_pal(travel_time), # Define color
stroke = F, # Turn off the outer border lines of circles
radius = 300, # Size of the circle
fillOpacity = 0.7, # Transparency
popup = paste0("Travel Time from <br> <strong> MIDTOWN: ", round(trvt$travel_time/60, 2), " minutes <strong>") %>% # Defines what's displayed on popup
lapply(htmltools::HTML))
# Average time to get to other stations
print(str_c("On average, it takes ",
round(mean(trvt$travel_time)/60,1),
" minutes to travel from the Midtown Station to all other stations."))
# Filter out rail transit
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
unique_shape <- route_trip %>%
dplyr::group_by(route_id) %>%
dplyr::slice(1) %>%
dplyr::ungroup()
route.shape <- atlsf$shape %>% inner_join(unique_shape, by = "shape_id")
# Route type is not really intuitive - let's fix that
route.shape <- route.shape %>%
dplyr::mutate(route_type = dplyr::case_when(
route_type == "0" ~ 'Tram, Streetcar',
route_type == "1" ~ 'Subway, Metro',
route_type == "2" ~ 'Rail',
route_type == "3" ~ 'Bus'
))
pal <- leaflet::colorFactor(c("red", "orange", "pink"), domain = route.shape$route_type)
route.shape %>%
leaflet::leaflet(data = .) %>%
leaflet::addProviderTiles(providers$CartoDB.DarkMatter) %>%
leaflet::addPolylines(color = ~pal(route_type),
weight = 3,
opacity = 0.9,
popup = paste0("Route type: ", route.shape$route_type))
# If we do not convert CRS to a projected one, the buffer may generate a ragged boundaries.
# https://r-spatial.github.io/sf/articles/sf7.html#buffers-1
# https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry
sf::sf_use_s2(TRUE)
MARTA_buffer <- route.shape %>%
sf::st_transform(crs = 26967) %>%
sf::st_buffer(dist = units::set_units(400, "m"))
MARTA_buffer_group <- MARTA_buffer %>%
group_by(route_type) %>%
summarise()
# If we do not convert CRS to a projected one, the buffer may generate a ragged boundaries.
# https://r-spatial.github.io/sf/articles/sf7.html#buffers-1
# https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry
sf::sf_use_s2(TRUE)
MARTA_buffer <- route.shape %>%
sf::st_transform(crs = 26967) %>%
sf::st_buffer(dist = units::set_units(400, "m"))
MARTA_buffer_group <- MARTA_buffer %>%
group_by(route_type) %>%
summarise()
pal <- colorFactor(palette = c("red", "yellow", "blue"), domain = MARTA_buffer_group$route_type)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = MARTA_buffer_group %>% st_transform(crs = 4326), col = ~pal(route_type),
popup = MARTA_buffer_group$route_type)
# If we do not convert CRS to a projected one, the buffer may generate a ragged boundaries.
# https://r-spatial.github.io/sf/articles/sf7.html#buffers-1
# https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry
sf::sf_use_s2(TRUE)
MARTA_buffer <- route.shape %>%
sf::st_transform(crs = 4326) %>%
sf::st_buffer(dist = units::set_units(400, "m"))
MARTA_buffer_group <- MARTA_buffer %>%
group_by(route_type) %>%
summarise()
pal <- colorFactor(palette = c("red", "yellow", "blue"), domain = MARTA_buffer_group$route_type)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = MARTA_buffer_group %>% st_transform(crs = 4326), col = ~pal(route_type),
popup = MARTA_buffer_group$route_type)
devtools::install_github("gadenbuie/rsthemes")
rsthemes::install_rsthemes(include_base16 = TRUE)
# Import required packages
library(tidytransit)
library(tidyverse)
library(tmap)
library(ggplot2)
# library(gtfsrouter)
library(here)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(plotly)
# library(igraph)
library(tidygraph)
# library(dodgr)
library(leafsync)
# source("https://raw.githubusercontent.com/BonwooKoo/gtfs_to_igraph/master/gtfs_to_igraph.R")
wd <- file.path(Sys.getenv('setwd'),"work/working/School/UA_2022/external/Lab/module_2")
setwd(eval(wd))
# This GTFS file is downloaded from
# https://opendata.atlantaregional.com/datasets/marta-gtfs-latest-feed/about
atl <- read_gtfs('MARTA_GTFS_Latest_Feed.zip')
typeof(atl)
names(atl)
print(head(atl))
# Converting GTFS data into sf objects
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
atlsf$stops %>% head() # Notice that this is POINT
atlsf$shapes %>% head() # This is LINESTRING
# Visualize
a <- leaflet(atlsf$shapes) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addPolylines(weight = 1, color = "red") %>% # add lines
addControl(htmltools::HTML("Route shapes")) # add Title
b <- leaflet(atlsf$stops) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addCircles(weight = 3, color = "red") %>% # add circles
addControl(htmltools::HTML("Stop shapes")) # add Title
leafsync::sync(a,b)
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
route_trip
route_trip
atlsf$shape
atl$trips
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
route_trip_shape <- route_trip %>% dplyr::left_join(atl$shapes, by = "shape_id")
route_trip_shape
nrow(route_trip)
nrow(route_trip_shape)
route_trip_shape
route_trip_shape %>% print(n = 50)
trip_shape <- atl$trips %>% dplyr::left_join(atl$shapes, by = "shape_id")
trip_shape
trip_shape %>% distinct(route_id, trip_id, shape_id)
# Join routes table with trips table using 'route_id' as key
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
# For each route_id, extract only one of them
unique_shape <- route_trip %>%
dplyr::group_by(route_id) %>%
dplyr::slice(1) %>%
dplyr::ungroup()
route.shape <- atlsf$shape %>% inner_join(unique_shape, by = "shape_id")
# Route type is not really intuitive - let's fix that
route.shape <- route.shape %>%
dplyr::mutate(route_type = dplyr::case_when(
route_type == "0" ~ 'Tram, Streetcar',
route_type == "1" ~ 'Subway, Metro',
route_type == "2" ~ 'Rail',
route_type == "3" ~ 'Bus'
))
route.shape
route.shape
route_trip
atlsf$shapes
atlsf$shapes %>% tm_shape(.) + tm_lines()
tmap_mode('view')
atlsf$shapes %>% tm_shape(.) + tm_lines()
st_write(altsf$shapes, "C:/Users/bkoo34/Downloads/shapes.geojson")
st_write(atlsf$shapes, "C:/Users/bkoo34/Downloads/shapes.geojson")
route_trip_shape
route_trip_shape %>% distinct(route_id, trip_id, shape_id) %>% st_write("C:/Users/bkoo34/Downloads/shapes.geojson")
route_trip_shape
route_trip_shape %>% distinct(route_id, trip_id, shape_id)
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
trip_shape <- atl$trips %>% dplyr::left_join(atl$shapes, by = "shape_id")
route_trip_shape <- atlsf$shapes %>% dplyr::left_join(route_trip, by = "shape_id")
route_trip_shape
route_trip_shape <- atlsf$shapes %>% dplyr::full_join(route_trip, by = "shape_id")
route_trip_shape
route_trip <- atl$trips %>% dplyr::left_join(atl$routes, by = "route_id")
trip_shape <- atl$trips %>% dplyr::left_join(atl$shapes, by = "shape_id")
route_trip <- atl$trips %>% dplyr::full_join(atl$routes, by = "route_id")
trip_shape <- atl$trips %>% dplyr::full_join(atlsf$shapes, by = "shape_id")
route_trip <- atl$trips %>% dplyr::full_join(atl$routes, by = "route_id")
trip_shape <- atl$trips %>% dplyr::full_join(atlsf$shapes, by = "shape_id")
route_trip_shape <- trip_shape %>% dplyr::full_join(route_trip, by = "trip_id")
route_trip_shape
trip_routes <- atl$trips %>% dplyr::full_join(atl$routes, by = "route_id")
trip_shape <- atl$trips %>% dplyr::full_join(atlsf$shapes, by = "shape_id")
route_trip_shape <- trip_shape %>% dplyr::full_join(trip_routes, by = "trip_id")
route_trip_shape
trip_shape
trip_shape <- atlsf$shapes %>% dplyr::full_join(atl$trips, by = "shape_id")
trip_shape
route_trip_shape <- trip_shape %>% dplyr::full_join(trip_routes, by = "trip_id")
route_trip_shape
route_trip_shape %>% st_write("C:/Users/bkoo34/Downloads/shape.geojson")
# Import required packages
library(tidytransit)
library(tidyverse)
library(tmap)
library(ggplot2)
# library(gtfsrouter)
library(here)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(plotly)
# library(igraph)
library(tidygraph)
# library(dodgr)
library(leafsync)
# source("https://raw.githubusercontent.com/BonwooKoo/gtfs_to_igraph/master/gtfs_to_igraph.R")
wd <- file.path(Sys.getenv('setwd'),"work/working/School/UA_2022/external/Lab/module_2")
setwd(eval(wd))
# This GTFS file is downloaded from
# https://opendata.atlantaregional.com/datasets/marta-gtfs-latest-feed/about
atl <- read_gtfs('MARTA_GTFS_Latest_Feed.zip')
typeof(atl)
names(atl)
print(head(atl))
# Converting GTFS data into sf objects
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
atlsf$stops %>% head() # Notice that this is POINT
atlsf$shapes %>% head() # This is LINESTRING
# Visualize
a <- leaflet(atlsf$shapes) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addPolylines(weight = 1, color = "red") %>% # add lines
addControl(htmltools::HTML("Route shapes")) # add Title
b <- leaflet(atlsf$stops) %>% # add data to display
addProviderTiles(providers$CartoDB.DarkMatter) %>% # add BaseMap
addCircles(weight = 3, color = "red") %>% # add circles
addControl(htmltools::HTML("Stop shapes")) # add Title
leafsync::sync(a,b)
# Join routes table with trips table with shapes table
trip_routes <- atl$trips %>%
full_join(atl$routes, by = "route_id")
trip_shape <- atlsf$shapes %>%
full_join(atl$trips %>%
select(shape_id, trip_id),
by = "shape_id")
route_trip_shape <- trip_shape %>%
select(-shape_id) %>%
full_join(trip_routes, by = c("trip_id"))
# Route type is not really intuitive - let's fix that
route.shape <- route_trip_shape %>%
mutate(route_type = case_when(
route_type == "0" ~ 'Tram, Streetcar',
route_type == "1" ~ 'Subway, Metro',
route_type == "2" ~ 'Rail',
route_type == "3" ~ 'Bus'
))
route.shape
route.shape %>% st_set_geometry(NULL) %>% group_by(shape_id, route_id) %>% summarise(n = n())
route.shape %>% group_by(shape_id, route_id) %>% slice(1) %>% st_write("C:/Users/bkoo34/Downloads/shape_route_id.geojson")
# Join routes table with trips table with shapes table
trip_routes <- atl$trips %>%
full_join(atl$routes, by = "route_id")
trip_shape <- atlsf$shapes %>%
full_join(atl$trips %>%
select(shape_id, trip_id),
by = "shape_id")
# Merging the two into one and then taking only one row for each
# unique combination of route_id and shape_id.
route_trip_shape <- trip_shape %>%
select(-shape_id) %>%
full_join(trip_routes, by = c("trip_id")) %>%
group_by(shape_id, route_id) %>%
slice(1)
# Route type is not really intuitive - let's fix that
route.shape <- route_trip_shape %>%
mutate(route_type = case_when(
route_type == "0" ~ 'Tram, Streetcar',
route_type == "1" ~ 'Subway, Metro',
route_type == "2" ~ 'Rail',
route_type == "3" ~ 'Bus'
))
route.shape
pal <- leaflet::colorFactor(c("red", "orange", "pink"), domain = route.shape$route_type)
route.shape %>%
leaflet::leaflet(data = .) %>%
leaflet::addProviderTiles(providers$CartoDB.DarkMatter) %>%
leaflet::addPolylines(color = ~pal(route_type),
weight = 3,
opacity = 0.9,
popup = paste0("Route type: ", route.shape$route_type))
# If we do not convert CRS to a projected one, the buffer may generate a ragged boundaries.
# https://r-spatial.github.io/sf/articles/sf7.html#buffers-1
# https://r-spatial.org/r/2020/06/17/s2.html#sf-10-goodbye-flat-earth-welcome-s2-spherical-geometry
sf::sf_use_s2(TRUE) # This is default to TRUE when we load SF package. So this code is not really needed. I added it here just to make it more explicit.
MARTA_buffer <- route.shape %>%
sf::st_transform(crs = 26967) %>%
sf::st_buffer(dist = units::set_units(400, "m"))
MARTA_buffer_group <- MARTA_buffer %>%
group_by(route_type) %>%
summarise()
MARTA_buffer
MARTA_buffer_group
pal <- colorFactor(palette = c("red", "yellow", "blue"), domain = MARTA_buffer_group$route_type)
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolygons(data = MARTA_buffer_group %>% st_transform(crs = 4326), col = ~pal(route_type),
popup = MARTA_buffer_group$route_type)
