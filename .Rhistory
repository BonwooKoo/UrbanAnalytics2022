radius = round(tract_center$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test %>% head()
# See the structure
businesses <- as_tibble(test$businesses)
print(businesses)
businesses
businesses %>%
pull(categories) %>%
reshape2::melt()
tester <- data.frame(id = seq(1,10), a = rnorm(10), b = rnorm(10))
tester
tester %>%
tester %>% mutate(ab = nest(a,b))
?nest
tester %>% nest(ab=c(a,b))
tester %>% nest(ab=c(a,b)) %>% jsonlite::flatten()
tester %>% mutate(ab = data.frame(a = a, b = b))
tester %>% mutate(ab = data.frame(a = a, b = b)) %>% str()
tester %>% mutate(ab = data.frame(a = a, b = b)) %>% jsonlite::flatten()
businesses %>%
jsonlite::flatten()
businesses <- businesses %>%
jsonlite::flatten()
businesses
businesses
# See the structure
businesses <- as_tibble(test$businesses)
#
businesses <- businesses %>%
jsonlite::flatten()
businesses
# See the structure
businesses <- as_tibble(test$businesses)
businesses
businesses
#
businesses <- businesses %>%
jsonlite::flatten()
businesses
str(businesses)
melt(businesses$alias)
melt(businesses$review_count)
businesses$transactions
businesses$transactions %>% melt
businesses %>%
tidyr::unnest_auto(col = c(categories))
businesses %>%
tidyr::unnest_auto(col = c(categories))
?unnest_auto
businesses %>%
tidyr::unnest_wider(col = c(categories))
businesses %>%
tidyr::unnest_longer(col = c(categories))
businesses
businesses$categories
businesses <- businesses %>%
tidyr::unnest_longer(col = c(categories))
businesses$categories
# See the structure
businesses <- as_tibble(test$businesses)
businesses %>%
tidyr::unnest_wider(col = c(categories))
businesses$categories
map(businsses,class)
map(businesses,class)
map_chr(businesses,class)
# See the structure
businesses <- as_tibble(test$businesses)
print(businesses)
businesses
businesses <- businesses %>%
tidyr::unnest_wider(col = c(transactions, coordinates, location))
businesses
head(businesses)
businesses %>% print(width = 1000)
# See the structure
businesses <- as_tibble(test$businesses)
businesses <- businesses %>%
jsonlite::flatten()
businesses
map(businesses, class)
knitr::opts_chunk$set(echo = TRUE)
tidycensus::census_api_key(Sys.getenv("census_api"))
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
tract %>% head() %>% knitr::kable()
# Retaining only those I want.
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE,
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
# st_centroid() converts POLYGON or LINESTRING geometry to POINT.
tract_center <- st_centroid(tract) %>% st_transform(4326)
# st_coordinates() returns a matrix of XY coordinates of the points that make up the geometric information
tract_center$x <- st_coordinates(tract_center)[,1]
tract_center$y <- st_coordinates(tract_center)[,2]
# View it
tract_center %>% head %>% kable()
# Function: Get tract-wise radius
get_r <- function(poly){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_p <- st_point(c(bb[1], bb[2]))
# Get centroid of the bb
c <- st_centroid(poly)
# Get the distance between bb_p and c
r <- st_distance(bb_p, c)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
r <- r*1.2
return(r)
}
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
r4all_loop <- rep(NA, nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[i] <- tract %>%
st_transform(crs = 26967) %>%
st_geometry() %>%
.[[i]] %>%
get_r()
}
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = 26967) %>%
sapply(., function(x) get_r(x))
# Check if they generated identical values
print(sum(r4all_loop - r4all_apply))
# Assign the radius as one of the columns of tract_center
tract_center$radius <- r4all_apply
tmap_mode('view')
# Select the first 10 rows
tract_center[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(tract[1:10,]) + tm_borders(col= 'blue')
which_tract <- 1
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'restaurant', # return only restaurant businesses
latitude = tract_center$y[which_tract],
longitude = tract_center$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(tract_center$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test %>% head()
# See what's inside
names(test)
# Business
paste0("is it a data.frame?: ", is.data.frame(test$businesses), ", ",
" how many rows?: ", nrow(test$businesses), ", ",
" how many columns?: ", ncol(test$businesses))
test$businesses %>% head(2)
test$total %>% head()
test$region %>% head()
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
print(paste0("Required_n: ", required_n))
# Collector
out <- vector("list", required_n)
# Create an empty NA data frame to fill in the data
out[[n]] <- resp$businesses
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
print(paste0("Current n: ", n))
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
return(out)
}
# Apply the function for the first Census Tract
yelp_first_tract <- get_yelp(tract_center[1,], "restaurant") %>%
bind_rows() %>%
as_tibble()
# Print
yelp_first_tract %>% print
# Prepare a collector
yelp_all_list <- vector("list", nrow(tract_center))
# Looping through all Census Tracts
for (row in 1:nrow(tract_center)){
yelp_all_list[row] <- get_yelp(tract_center[row,], "restaurant")
}
yelp_all_list
row <- tract_center[93,]
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = row$y,
longitude = row x,
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = row$y,
longitude = row$x,
offset = (n - 1) * 50, # = 0
radius = round(row$radius),
limit = 50)
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = "restaurant",
latitude = row$y,
longitude = row$x,
offset = (n - 1) * 50, # = 0
radius = round(row$radius),
limit = 50)
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = "restaurant",
latitude = row$y,
longitude = row$x,
offset = 0
radius = round(row$radius),
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = "restaurant",
latitude = row$y,
longitude = row$x,
offset = 0,
radius = round(row$radius),
limit = 50)
resp
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
if (required_n <= 1) return(resp)
# Collector
out <- vector("list", required_n)
# Create an empty NA data frame to fill in the data
out[[n]] <- resp$businesses
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
out <- out %>% bind_rows()
return(out)
}
# Apply the function for the first Census Tract
yelp_first_tract <- get_yelp(tract_center[93,], "restaurant") %>%
as_tibble()
yelp_first_tract
map(yelp_all_list,length)
tract_center <- tract_center[1:100,]
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
if (required_n <= 1) return(resp)
# Collector
out <- vector("list", required_n)
# Create an empty NA data frame to fill in the data
out[[n]] <- resp$businesses
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
out <- out %>% bind_rows()
return(out)
}
10/50
ceilingO010/50
ceiling(10/50)
0/50
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
if (required_n <= 1) return(resp)
# Collector
out <- vector("list", required_n)
# Create an empty NA data frame to fill in the data
out[[n]] <- resp$businesses
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
out <- out %>% bind_rows()
return(out)
}
7%%5
# Prepare a collector
yelp_all_list <- vector("list", nrow(tract_center))
# Looping through all Census Tracts
for (row in 1:nrow(tract_center)){
yelp_all_list[row] <- get_yelp(tract_center[row,], "restaurant")
if (row %% 50 == 0){
print("Current row: ", row)
}
}
yelp_all_list
# Prepare a collector
yelp_all_list <- vector("list", nrow(tract_center))
# Looping through all Census Tracts
for (row in 1:nrow(tract_center)){
yelp_all_list[row] <- get_yelp(tract_center[row,], "restaurant")
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
# Collapsing the list into a data.frame
yelp_all <- yelp_all_list %>% bind_rows() %>% as_tibble()
map(yelp_all_list,length)
yelp_all_list[100]
yelp_all_list
yelp_all_list[[1]]
yelp_first_tract
yelp_first_tract
tract_center <- tract_center[1:10]
tract_center <- tract_center[1:10,]
# Prepare a collector
yelp_all_list <- vector("list", nrow(tract_center))
yelp_all_list
# Looping through all Census Tracts
for (row in 1:nrow(tract_center)){
yelp_all_list[row] <- get_yelp(tract_center[row,], "restaurant")
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
yelp_all_list
# Prepare a collector
yelp_all_list <- vector("list", nrow(tract_center))
for (row in 1:nrow(tract_center)){
yelp_all_list[[row]] <- get_yelp(tract_center[row,], "restaurant")
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
yelp_all_list
select <- matrix(ncol = 2, byrow = F, c(
1, 1,
3, 1,
2, 4
))
x <- list(abc = 1)
x
x$a
x <- list(abc = 1, abd = 2)
x
x$a
x$ab
x <- list(abc = 1, add = 2)
x$ad
x <-1:5
x
x[-1]
x[-1] <- 4:1
x
df <- data.frame(a = c(1, 10, NA))
df$a>5
df
df$a[df$a>5]
library(tidyverse)
library(here)
here()
xaringan:::inf_mr()
my_df <- read_csv("https://raw.githubusercontent.com/BonwooKoo/UrbanAnalytics2022/main/Lab/module_0/testdata.csv")
my_df
xaringan:::inf_mr()
xaringan:::inf_mr()
a
a <- letters[1:5]
xaringan:::inf_mr()
a <- letters[1:5]
a
match("a", a)
match("c", a)
which("c", a)
?which
which(c("a", "c"), a)
which(c("a", "c") %in% as)
which(c("a", "c") %in% a)
a
a[which("a", a)]
a[which("a"== a)]
which("a" == a)
which("c" == a)
which(c("a", "b") == a)
which(a %in% c("a", "c"))
xaringan:::inf_mr()
