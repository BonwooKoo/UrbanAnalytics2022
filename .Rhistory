limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# Collector
out <- vector("list", required_n)
# Create an empty NA data frame to fill in the data
out[[n]] <- resp$businesses
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
print(glue::glue("{n}th row has >= 1000 businesses."))
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
out <- out %>% bind_rows()
return(out)
}
}
# Apply the function for the first Census Tract
yelp_first_tract <- get_yelp(ready_4_yelp[1,], "restaurant") %>%
as_tibble()
# Print
yelp_first_tract %>% print
# Prepare a collector
yelp_all_list <- vector("list", nrow(ready_4_yelp))
# Looping through all Census Tracts
for (row in 1:3){
yelp_all_list[[row]] <- get_yelp(ready_4_yelp[row,], "restaurant")
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
# Collapsing the list into a data.frame
yelp_all <- yelp_all_list %>% bind_rows() %>% as_tibble()
# print
yelp_all %>% print(width=1000)
yelp_all
yelp_all %>% print(width = 1000)
names(yelp_all)
yelp_all %>% as_tibble() %>% print(width = 1000)
yelp_all %>% as_tibble() %>% print(width = 1000)
yelp_all$location
yelp_all$location %>% head()
yelp_all %>%
as_tibble() %>%
slice(1)
yelp_all %>%
as_tibble() %>%
slice(1) %>%
kable()
yelp_all %>%
as_tibble() %>%
slice(1) %>%
kable()
resp_parsed
yelp_all
yelp_all$location
yelp_all$coordinates
dim(yelp_all$coordinates)
dim(yelp_all)
# Extract coordinates
yelp_all$x <- yelp_all$coordinates$longitude
yelp_all$y <- yelp_all$coordinates$latitude
yelp_all
yelp_all %>%
mutate(x = .$coordinates$longitude)
yelp_all %>%
mutate(x = .$coordinates$longitude) %>% print(width = 1000)
yelp_all %>%
mutate(xy = .$coordinates$longitude) %>% print(width =1000)
# Map
tm_shape(yelp_all) +
tm_dots(col = "review_count")
# Extract coordinates
yelp_sf <- yelp_all %>%
mutate(x = .$coordinates$longitude,
y = .$coordinates$latitude) %>%
st_as_sf(coords = c("x", "y"), crs = 4326)
# Map
tm_shape(yelp_sf) +
tm_dots(col = "review_count")
sum(duplicated(yelp_sf$id))
duplicated(yelp_sf$id)
nrow(yelp_all)
# Extract coordinates
yelp_sf <- yelp_all %>%
mutate(x = .$coordinates$longitude,
y = .$coordinates$latitude) %>%
st_as_sf(coords = c("x", "y"), crs = 4326)
# Map
tm_shape(yelp_sf) +
tm_dots(col = "review_count")
knitr::opts_chunk$set(echo = TRUE)
tidycensus::census_api_key(Sys.getenv("census_api"))
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
tract %>% head() %>% knitr::kable()
# Retaining only those I want.
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
# Function: Get tract-wise radius
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
epsg_id <- 26967 # should be unit=meter.
r4all_loop <- vector("list", nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
# Appending X Y coordinates as seprate columns
ready_4_yelp <- r4all_apply %>%
# Transform back to 4326, because that's what Yelp takes
st_transform(crs = 4326) %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
tmap_mode('view')
# Select the first 10 rows
ready_4_yelp[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(tract[1:10,]) + tm_borders(col= 'blue')
# Function for formatting the url for API request
url_format <- function(latitude = NULL, longitude = NULL,
radius = NULL, categories = NULL, offset = NULL, limit = NULL){
# Parameters
base_url <- "https://api.yelp.com/v3/businesses/search?"
latitude <- paste0("latitude=", latitude)
longitude <- paste0("longitude=", longitude)
radius <- paste0("radius=", radius)
categories <- paste0("categories=", categories)
offset <- paste0("offset=", offset)
limit <- paste0("limit=", limit)
# Out
full_url <- paste0(c(base_url, latitude, longitude, radius, categories, offset, limit), collapse = "&")
return(full_url)
}
# Run url_format function
full_url <- url_format(latitude = 33.792479078196294, # This is Atlantic station
longitude = -84.39676077444938, # This is Atlantic station
radius=1000,
categories="restaurant",
offset = 0,
limit = 50)
# GET response
resp <- httr::GET(full_url, add_headers(Authorization = paste("Bearer", Sys.getenv("yelp_api"))))
# Parse the body of the response (json format)
resp_parsed <- content(resp, as="text", encoding = "UTF-8")
# Parse json into a list
resp_parsed <- jsonlite::fromJSON(resp_parsed)
resp_parsed$businesses %>% head %>% kable()
resp_raw <- content(resp, as = "raw")
resp_raw
which_tract <- 1
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'restaurant', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
test
# See what's inside
names(test)
# Business
paste0("is it a data.frame?: ", is.data.frame(test$businesses), ", ",
" how many rows?: ", nrow(test$businesses), ", ",
" how many columns?: ", ncol(test$businesses))
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# Collector
out <- vector("list", required_n)
# Create an empty NA data frame to fill in the data
out[[n]] <- resp$businesses
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
print(glue::glue("{n}th row has >= 1000 businesses."))
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
out <- out %>% bind_rows()
return(out)
}
}
# Apply the function for the first Census Tract
yelp_first_tract <- get_yelp(ready_4_yelp[1,], "restaurant") %>%
as_tibble()
# Print
yelp_first_tract %>% print
# Prepare a collector
yelp_all_list <- vector("list", nrow(ready_4_yelp))
# Looping through all Census Tracts
for (row in 1:nrow(ready_4_yelp)){
yelp_all_list[[row]] <- get_yelp(ready_4_yelp[row,], "restaurant")
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
# Collapsing the list into a data.frame
yelp_all <- yelp_all_list %>% bind_rows() %>% as_tibble()
# print
yelp_all %>% print(width=1000)
# Extract coordinates
yelp_sf <- yelp_all %>%
mutate(x = .$coordinates$longitude,
y = .$coordinates$latitude) %>%
st_as_sf(coords = c("x", "y"), crs = 4326)
yelp_all
yelp_sf <- yelp_all %>%
mutate(x = .$coordinates$longitude,
y = .$coordinates$latitude)
yelp_sf %>% pull(x,y)
yelp_sf %>% select(x,y)
yelp_sf %>% select(x,y) %>% filter(is.na(x) | is.na(y))
yelp_sf %>% select(x,y) %>% filter(is.na(x) | is.na(y)) %>% print(n= =1000)
yelp_sf %>% select(x,y) %>% filter(is.na(x) | is.na(y)) %>% print(n= 1000)
# Extract coordinates
yelp_sf <- yelp_all %>%
filter(!is.na(x) & !is.na(y)) %>%
mutate(x = .$coordinates$longitude,
y = .$coordinates$latitude) %>%
st_as_sf(coords = c("x", "y"), crs = 4326)
# Extract coordinates
yelp_sf <- yelp_all %>%
mutate(x = .$coordinates$longitude,
y = .$coordinates$latitude) %>%
filter(!is.na(x) & !is.na(y)) %>%
st_as_sf(coords = c("x", "y"), crs = 4326)
# Map
tm_shape(yelp_sf) +
tm_dots(col = "review_count")
row
suppressMessages(get_yelp(ready_4_yelp[row,], "restaurant"))
get_yelp(ready_4_yelp[row,], "restaurant")
xaringan:::inf_mr()
getwd()
xaringan:::inf_mr()
census <- sf::st_read("https://raw.githubusercontent.com/BonwooKoo/UrbanAnalytics2022/main/Lab/module_0/testdata.geojson")
census
census %>% st_geometry()
census %>% st_geometry() %>% class()
st_as_sf(c(-84, 33), crs = 4326)
st_as_sf(c(-84, 33), crs = 4326)
st_sf(c(-84, 33), crs = 4326)
census
census %>% print(width = 10000)
census %>% select(GEOID, tract, hhincome) %>% print(width = 10000)
knitr::include_graphics(here("Lab", "Module_0", "sf_strcuture.png"))
knitr::include_graphics(here::here("Lab", "Module_0", "sf_strcuture.png"))
knitr::include_graphics(here::here("Lab", "Module_1", "sf_strcuture.png"))
xaringan:::inf_mr()
census
census %>% select(GEOID, tract, hhincome)
xaringan:::inf_mr()
knitr::opts_chunk$set(echo = TRUE)
which_tract <- 1
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
category = 'restaurant', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
vector('list', 3)
a <- vector('list', 3)
lapply(a, head)
xaringan:::inf_mr()
census
census %>% st_geometry()
census %>% st_geometry() %>% .[[1]]
census %>% st_transform(crs = 26967)
my_point <- st_point(c(-84.388, 33.749))
my_point
my_sfc <- st_sfc(my_point, crs = 4326)
my_sfc
my_sf <- st_sf(my_sfc)
my_sf
knitr::opts_chunk$set(echo = TRUE)
tidycensus::census_api_key(Sys.getenv("census_api"))
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
tract %>% head() %>% knitr::kable() # Ignore this kable() function. This function is for neatly displaying tables on HTML document.
# Retaining only those I want.
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
# Function: Get tract-wise radius
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
epsg_id <- 26967 # should be unit=meter.
r4all_loop <- vector("list", nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
r4all_apply
## Using a loop -----------------------------------------------------------------
# Creating an empty vector of NA.
# Results will fill this vector
epsg_id <- 4326 # should be unit=meter.
r4all_loop <- vector("list", nrow(tract))
# Starting a for-loop
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# Using a functional -----------------------------------------------------------
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
r4all_loop
xaringan:::inf_mr()
?st_crs
a <- st_crs(4326, parameters=T)
str(a)
a$wkt
