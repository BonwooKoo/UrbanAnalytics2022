paths$node_paths[88]
paths$node_paths[1]
paths$node_paths[2]
paths$node_paths[3]
paths$node_paths[4]
paths$node_paths[90]
paths$node_paths[89]
paths$node_paths[88]
dist_all
dist_all
dist_all <- dist_all %>% unlist
dist_all
# Drop zeros
dist_all <- dist_all[dist_all>0]
?which.min
# Replace zeros with a large values
dist_all[dist_all == 0] <- max(dist_all)
dist_all
# Find the smallest one
closest_index <- which.min(dist_all)
# Extract shortest path
paths_closest <- atl_net %>%
slice(paths$node_paths[[closest_index]])
# Extract shortest path
paths_closest <- atl_net %>%
slice(paths$node_paths[[closest_index]])
# Visualize it
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Base network in grey
addPolylines(data = atl_net %>% st_as_sf("edges"), color = 'grey', weight = 2, opacity = 0.7) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"), color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"), stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50)
closest_index
paths$node_paths[49]
paths$node_paths
paths$node_paths[[49]]
# Extract shortest path
paths_closest <- atl_net %>%
slice(paths$node_paths[[closest_index]])
paths_closest
# Extract shortest path
paths_closest <- atl_net %>%
activate("nodes") %>%
slice(paths$node_paths[[closest_index]])
paths_closest
# Visualize it
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Base network in grey
addPolylines(data = atl_net %>% st_as_sf("edges"), color = 'grey', weight = 2, opacity = 0.7) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"), color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"), stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50)
rail_stops_point
# Visualize it
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Base network in grey
addPolylines(data = atl_net %>% st_as_sf("edges"), color = 'grey', weight = 2, opacity = 0.7) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"), color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"), stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50) +
# Chosen station
addCircles(data = transit$stops %>% filter(stop_id %in% rail_stops) %>% slice(closest_index))
# Visualize it
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Base network in grey
addPolylines(data = atl_net %>% st_as_sf("edges"), color = 'grey', weight = 2, opacity = 0.7) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"), color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"), stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50) %>%
# Chosen station
addCircles(data = transit$stops %>% filter(stop_id %in% rail_stops) %>% slice(closest_index))
# Change crs for convenience
atl_net <- atl_net %>% st_transform(4326) %>% activate("edges") %>% mutate(length = edge_length())
# Start point
start_p <- st_point(c(-84.40541505942419, 33.85097957563499)) %>% st_sfc(crs = 4326) # Some random residential location
# End point
rail_stops_point <- transit$stops %>% filter(stop_id %in% rail_stops) %>% st_geometry()
# Get the shortest path
paths = st_network_paths(atl_net, from = start_p, to = rail_stops_point, type = "shortest")
# Find the distances
dist_all <- map_dbl(1:nrow(paths), function(x){
atl_net %>% slice(paths$node_paths[[x]]) %>% st_as_sf("edges") %>% pull(length) %>% sum()
}) %>% unlist()
# Replace zeros with a large values
dist_all[dist_all == 0] <- max(dist_all)
# Find the smallest one
closest_index <- which.min(dist_all)
# Extract shortest path
paths_closest <- atl_net %>%
activate("nodes") %>%
slice(paths$node_paths[[closest_index]])
# Visualize it
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Base network in grey
addPolylines(data = atl_net %>% st_as_sf("edges"), color = 'grey', weight = 2, opacity = 0.7) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"), color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"), stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50) %>%
# Chosen station
addCircleMarkers(data = transit$stops %>% filter(stop_id %in% rail_stops) %>% slice(closest_index), fillColor = "blue", radius = 300)
# Visualize it
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Base network in grey
addPolylines(data = atl_net %>% st_as_sf("edges"), color = 'grey', weight = 2, opacity = 0.7) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"), color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"), stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50) %>%
# Chosen station
addCircles(data = transit$stops %>% filter(stop_id %in% rail_stops) %>% slice(closest_index), fillColor = "blue", radius = 300)
library(tidyverse)
library(tmap)
library(ggplot2)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(leafsync)
library(dbscan)
library(sfnetworks)
library(tigris)
library(tidygraph)
library(plotly)
library(osmdata)
library(here)
library(tidytransit)
library(units)
library(leaflet)
library(tidycensus)
library(leafsync)
epsg <- 4326
# Census API key
census_api_key(Sys.getenv('census_api'))
# Get ACS
census <- tidycensus::get_acs(geography = "tract",
variables = c("hhinc" = 'B19013_001',
"r_tot" = "B02001_001",
"r_wh" = "B02001_002",
"r_bl" = "B02001_003",
"tot_hh" = "B25044_001",
"own_novhc" = "B25044_003",
"rent_novhc" = "B25044_010"),
year = 2020,
output = "wide",
state = "GA",
county = c("Fulton", "DeKalb", "Clayton"),
geometry = TRUE) %>%
st_transform(crs = epsg) %>%
separate(col = NAME, into = c("tract", "county", "state"), sep = ", ")
# GTFS
gtfs <- tidytransit::read_gtfs("D:/Dropbox (GaTech)/Work/Working/School/UA_2022/external/Lab/module_2/MARTA_GTFS_Latest_Feed.zip")
?as_sfnetwork
library(tidyverse)
library(tmap)
library(ggplot2)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(leafsync)
library(dbscan)
library(sfnetworks)
library(tigris)
library(tidygraph)
library(plotly)
library(osmdata)
library(here)
library(tidytransit)
library(units)
library(leaflet)
library(tidycensus)
library(leafsync)
epsg <- 4326
# Census API key
census_api_key(Sys.getenv('census_api'))
# Get ACS
census <- tidycensus::get_acs(geography = "tract",
variables = c("hhinc" = 'B19013_001',
"r_tot" = "B02001_001",
"r_wh" = "B02001_002",
"r_bl" = "B02001_003",
"tot_hh" = "B25044_001",
"own_novhc" = "B25044_003",
"rent_novhc" = "B25044_010"),
year = 2020,
output = "wide",
state = "GA",
county = c("Fulton", "DeKalb", "Clayton"),
geometry = TRUE) %>%
st_transform(crs = epsg) %>%
separate(col = NAME, into = c("tract", "county", "state"), sep = ", ")
# GTFS
gtfs <- tidytransit::read_gtfs(here("external","Lab","module_2","MARTA_GTFS_Latest_Feed.zip"))
# Modify stop_name to append serial numbers (1, 2, etc.) to remove duplicate names
stop_dist <- stop_group_distances(gtfs$stops, by='stop_name') %>%
filter(dist_max > 200)
gtfs$stops <- gtfs$stops %>%
group_by(stop_name) %>%
mutate(stop_name = case_when(stop_name %in% stop_dist$stop_name ~ paste0(stop_name, " (", seq(1,n()), ")"),
TRUE ~ stop_name))
# Create a transfer table
gtfs$transfers <- gtfsrouter::gtfs_transfer_table(gtfs,
d_limit = 200,
min_transfer_time = 120)
# NOTE: Converting to sf format uses stop_lat and stop_lon columns contained in gtfs$stops.
#       In the conversion process, stop_lat and stop_lon are converted into a geometry column, and
#       the output sf object do not have the lat lon column anymore.
#       But many other functions in tidytransit look for stop_lat and stop_lon.
#       So I re-create them using mutate().
gtfs <- gtfs %>% gtfs_as_sf(crs = epsg)
gtfs$stops <- gtfs$stops %>%
ungroup() %>%
mutate(stop_lat = st_coordinates(.)[,2],
stop_lon = st_coordinates(.)[,1])
# Extract route id for rail and bus gtfs
rail_route <- gtfs$routes %>% filter(route_type %in% c(0,1,2)) %>% pull(route_id)
bus_route <- gtfs$routes %>% filter(route_type==3) %>% pull(route_id)
# Get stop_id for rails and buses
rail_stops <- gtfs$routes %>%
filter(route_type %in% c(0,1,2)) %>%
inner_join(gtfs$trips, by = "route_id") %>%
inner_join(gtfs$stop_times, by = "trip_id") %>%
inner_join(gtfs$stops, by = "stop_id") %>%
group_by(stop_id) %>%
slice(1) %>%
pull(stop_id)
bus_stops <- gtfs$routes %>%
filter(route_type %in% c(3)) %>%
inner_join(gtfs$trips, by = "route_id") %>%
inner_join(gtfs$stop_times, by = "trip_id") %>%
inner_join(gtfs$stops, by = "stop_id") %>%
group_by(stop_id) %>%
slice(1) %>%
pull(stop_id)
bbox <- gtfs$stops %>% ungroup() %>%
filter(stop_id %in% rail_stops) %>%
st_bbox() %>% st_as_sfc() %>%
st_buffer(set_units(5, mile)) %>%
st_bbox()
# # Get bounding box coordinates for Atlanta
# p1 <- c(33.62545038577594, -84.5333226162096)
# p2 <- c(33.97712784386075, -84.20663601299125)
#
# # Custom BB
# my_bb <- matrix(c(p1[2], p1[1],
#                   p2[2], p2[1]), ncol = 2) %>%
#
# colnames(my_bb) <- c("min", "max")
# rownames(my_bb) <- c("x", "y")
#
#
# # Custom BB to sf
# my_bb_sf <- my_bb %>% t %>% data.frame() %>%
#   st_as_sf(coords = c("x", "y"), crs = 4326) %>%
#   st_bbox() %>%
#   st_as_sfc()
#
# ## Map it
# tmap_mode('view')
# tm_shape(my_bb_sf) + tm_borders(col = "black")
# Get OSM data
osm_road <- opq(bbox = bbox) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
# Covert to sfnetworks data &
# Clean it
osm <- osm_road$osm_lines %>%
sfnetworks::as_sfnetwork() %>%
st_transform(crs = epsg) %>%
activate("edges") %>%
filter(!edge_is_multiple()) %>%
filter(!edge_is_loop()) %>%
convert(., sfnetworks::to_spatial_subdivision) %>%
convert(., sfnetworks::to_spatial_smooth)
# Add length column
osm <- osm %>%
activate("edges") %>%
mutate(length = edge_length())
home <- census %>% st_centroid() %>% .[bbox %>% st_as_sfc(crs = 4326),,op=st_intersects]
station <- gtfs$stops %>% filter(stop_id %in% rail_stops)
midtown <- gtfs$stops %>% filter(stop_code == "134")
## ----------------------------------------------
## From home the nearest station
## ----------------------------------------------
# Shortest route from Home 1 to stations
home_1 <- home[30,]
# Get routes
paths = st_network_paths(osm, from = home_1, to = station, type = "shortest")
# Find the distances
dist_all <- map_dbl(1:nrow(paths), function(x){
osm %>% activate("nodes") %>% slice(paths$node_paths[[x]]) %>% st_as_sf("edges") %>% pull(length) %>% sum()
}) %>% unlist()
# Replace zeros with a large values
dist_all[dist_all == 0] <- max(dist_all)
# Find the smallest one
closest_index <- which.min(dist_all)
closest_dist <- dist_all[closest_index]
car_speed <- set_units(30, mile/h)
trvt_osm_m <- closest_dist/set_units(car_speed, m/min) %>%  # Distance divided by 30 mile/h
as.vector()
# Extract shortest path
paths_closest <- osm %>%
activate("nodes") %>%
slice(paths$node_paths[[closest_index]])
closest_station <- gtfs$stops %>% filter(stop_id %in% rail_stops) %>% slice(closest_index)
# Step 7. Map it!
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"),
color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"),
stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50) %>%
# Chosen station
addCircles(data = closest_station, fillColor = "blue", radius = 300)
## ----------------------------------------------
## From the nearest station to midtown
## ----------------------------------------------
# Define the time window for calculating the travel time
am_stop_time <- filter_stop_times(gtfs_obj = gtfs,
extract_date = "2021-08-14",
min_departure_time = 3600*7, # input unit is in second. So 3500*7 is 7AM
max_arrival_time = 3600*10)  # similarly, this is 10AM
# travel_times
trvt <- travel_times(filtered_stop_times = am_stop_time,
stop_name = closest_station$stop_name,
return_coords = TRUE) %>%
filter(to_stop_name == midtown$stop_name)
trvt_gtfs_m <- trvt$travel_time/60
## ----------------------------------------------
## Total Travel time
## ----------------------------------------------
total_trvt <- trvt_osm_m + trvt_gtfs_m
library(tidyverse)
library(tmap)
library(ggplot2)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(leafsync)
library(dbscan)
library(sfnetworks)
library(tigris)
library(tidygraph)
library(plotly)
library(osmdata)
library(here)
library(tidytransit)
library(units)
library(leaflet)
library(tidycensus)
library(leafsync)
epsg <- 4326
# GTFS
gtfs <- tidytransit::read_gtfs(here("external","Lab","module_2","MARTA_GTFS_Latest_Feed.zip"))
# Modify stop_name to append serial numbers (1, 2, etc.) to remove duplicate names
stop_dist <- stop_group_distances(gtfs$stops, by='stop_name') %>%
filter(dist_max > 200)
gtfs$stops <- gtfs$stops %>%
group_by(stop_name) %>%
mutate(stop_name = case_when(stop_name %in% stop_dist$stop_name ~ paste0(stop_name, " (", seq(1,n()), ")"),
TRUE ~ stop_name))
# Create a transfer table
gtfs$transfers <- gtfsrouter::gtfs_transfer_table(gtfs,
d_limit = 200,
min_transfer_time = 120)
# NOTE: Converting to sf format uses stop_lat and stop_lon columns contained in gtfs$stops.
#       In the conversion process, stop_lat and stop_lon are converted into a geometry column, and
#       the output sf object do not have the lat lon column anymore.
#       But many other functions in tidytransit look for stop_lat and stop_lon.
#       So I re-create them using mutate().
gtfs <- gtfs %>% gtfs_as_sf(crs = epsg)
gtfs$stops <- gtfs$stops %>%
ungroup() %>%
mutate(stop_lat = st_coordinates(.)[,2],
stop_lon = st_coordinates(.)[,1])
# Get stop_id for rails and buses
rail_stops <- gtfs$routes %>%
filter(route_type %in% c(0,1,2)) %>%
inner_join(gtfs$trips, by = "route_id") %>%
inner_join(gtfs$stop_times, by = "trip_id") %>%
inner_join(gtfs$stops, by = "stop_id") %>%
group_by(stop_id) %>%
slice(1) %>%
pull(stop_id)
station <- gtfs$stops %>% filter(stop_id %in% rail_stops)
midtown <- gtfs$stops %>% filter(stop_code == "134")
bbox <- gtfs$stops %>% ungroup() %>%
filter(stop_id %in% rail_stops) %>%
st_bbox() %>% st_as_sfc() %>%
st_buffer(set_units(5, mile)) %>%
st_bbox()
# Census API key
census_api_key(Sys.getenv('census_api'))
# Get ACS
census <- tidycensus::get_acs(geography = "tract",
variables = c("hhinc" = 'B19013_001',
"r_tot" = "B02001_001",
"r_wh" = "B02001_002",
"r_bl" = "B02001_003",
"tot_hh" = "B25044_001",
"own_novhc" = "B25044_003",
"rent_novhc" = "B25044_010"),
year = 2020,
output = "wide",
state = "GA",
county = c("Fulton", "DeKalb", "Clayton"),
geometry = TRUE) %>%
st_transform(crs = epsg) %>%
separate(col = NAME, into = c("tract", "county", "state"), sep = ", ")
home <- census %>% st_centroid() %>% .[bbox %>% st_as_sfc(crs = 4326),,op=st_intersects]
# Get OSM data
osm_road <- opq(bbox = bbox) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
# Covert to sfnetworks data &
# Clean it
osm <- osm_road$osm_lines %>%
sfnetworks::as_sfnetwork(directed = FALSE) %>%
activate("edges") %>%
filter(!edge_is_multiple()) %>%
filter(!edge_is_loop()) %>%
convert(., sfnetworks::to_spatial_subdivision) %>%
convert(., sfnetworks::to_spatial_smooth)
# Add length column
osm <- osm %>%
activate("edges") %>%
mutate(length = edge_length())
## ----------------------------------------------
## From home the nearest station
## ----------------------------------------------
# Shortest route from Home 1 to stations
home_1 <- home[1,]
# Get routes
paths = st_network_paths(osm, from = home_1, to = station, type = "shortest")
# Find the distances
dist_all <- map_dbl(1:nrow(paths), function(x){
osm %>% activate("nodes") %>% slice(paths$node_paths[[x]]) %>% st_as_sf("edges") %>% pull(length) %>% sum()
}) %>% unlist()
# Replace zeros with a large values
dist_all[dist_all == 0] <- max(dist_all)
# Find the smallest one
closest_index <- which.min(dist_all)
closest_dist <- dist_all[closest_index]
car_speed <- set_units(30, mile/h)
trvt_osm_m <- closest_dist/set_units(car_speed, m/min) %>%  # Distance divided by 30 mile/h
as.vector()
# Extract shortest path
paths_closest <- osm %>%
activate("nodes") %>%
slice(paths$node_paths[[closest_index]])
closest_station <- gtfs$stops %>% filter(stop_id %in% rail_stops) %>% slice(closest_index)
# Step 7. Map it!
leaflet() %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
# Chosen edges
addPolylines(data = paths_closest %>% st_as_sf("edges"),
color = "red", weight = 10, opacity = 0.5) %>%
# Chosen nodes
addCircles(data = paths_closest %>% st_as_sf("nodes"),
stroke = F, fillColor = "red", fillOpacity = 0.8, radius = 50) %>%
# Chosen station
addCircles(data = closest_station, fillColor = "blue", radius = 300)
## ----------------------------------------------
## From the nearest station to midtown
## ----------------------------------------------
# Define the time window for calculating the travel time
am_stop_time <- filter_stop_times(gtfs_obj = gtfs,
extract_date = "2021-08-14",
min_departure_time = 3600*7, # input unit is in second. So 3500*7 is 7AM
max_arrival_time = 3600*10)  # similarly, this is 10AM
# travel_times
trvt <- travel_times(filtered_stop_times = am_stop_time,
stop_name = closest_station$stop_name,
return_coords = TRUE) %>%
filter(to_stop_name == midtown$stop_name)
trvt_gtfs_m <- trvt$travel_time/60
## ----------------------------------------------
## Total Travel time
## ----------------------------------------------
total_trvt <- trvt_osm_m + trvt_gtfs_m
home_1 <- home[1,]
# Get routes
paths = st_network_paths(osm, from = home_1, to = station, type = "shortest")
# Find the distances
dist_all <- map_dbl(1:nrow(paths), function(x){
osm %>% activate("nodes") %>% slice(paths$node_paths[[x]]) %>% st_as_sf("edges") %>% pull(length) %>% sum()
}) %>% unlist()
dist_all
?osm_poly2line
