radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'arts', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test_1 <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'Restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test_1, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'restaurant', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
categories = 'restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
test <- business_search(api_key = Sys.getenv('yelp_api'), # like we did for census, store your api key
# categories = 'restaurants', # return only restaurant businesses
latitude = ready_4_yelp$y[which_tract],
longitude = ready_4_yelp$x[which_tract],
offset = 0, # 1st page, 1st obs
radius = round(ready_4_yelp$radius[which_tract]), # radius requires integer value
limit = 50) # how many business per page
lapply(test, head)
knitr::opts_chunk$set(echo = TRUE)
census_api <- Sys.getenv("census_api")
yelp_api <- Sys.getenv("yelp_api")
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
# Function: Get tract-wise radius, used in for-loop later
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
##set coordinate system
epsg_id <- 4326
# Function for formatting the url for API request
url_format <- function(latitude = NULL, longitude = NULL,
radius = NULL, categories = NULL, offset = NULL, limit = NULL){
# Parameters
base_url <- "https://api.yelp.com/v3/businesses/search?"
latitude <- paste0("latitude=", latitude)
longitude <- paste0("longitude=", longitude)
radius <- paste0("radius=", radius)
categories <- paste0("categories=", categories)
offset <- paste0("offset=", offset)
limit <- paste0("limit=", limit)
# Out
full_url <- paste0(c(base_url, latitude, longitude, radius, categories, offset, limit), collapse = "&")
return(full_url)
}
# FUNCTION
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0 when n = 1
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# out is where the results will be appended to.
out <- vector("list", required_n)
# Store the business information to nth slot in out
out[[n]] <- resp$businesses
# Change the name of the elements to the total required_n
# This is to know if there are more than 1000 businesses,
# we know how many.
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
# glue formats string by inserting {n} with what's currently stored in object n.
print(glue::glue("{n}th row has >= 1000 businesses."))
# Stop before going into the loop because we need to
# break down Census Tract to something smaller.
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
# Merge all elements in the list into a single data frame
out <- out %>% bind_rows()
return(out)
}
}
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "NJ",
county = c("Essex"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
census_api_key(Sys.getenv('yelp_api'))
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "NJ",
county = c("Essex"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
census_api_key(Sys.getenv('census_api'))
#### Tract polygons for the Yelp query
tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "NJ",
county = c("Essex"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = 'B02001_003'
),
year = 2019,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# View the data, ROWS AND COLUMNS
message(sprintf("nrow: %s, ncol: %s", nrow(tract), ncol(tract)))
# This function is for neatly displaying tables on HTML document.
tract %>% head() %>% knitr::kable()
# Retaining only columns that end in E (estimate) and discard M (margin)
# Notice that select function can also change names when it selects columns.
tract <- tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE)
tmap_mode("view")
tm_shape(tract) + tm_borders()
#empty dataframe for census tracts
r4all_loop <- vector("list", nrow(tract))
#start for-loop to get radii for each census tract
for (i in 1:nrow(tract)){
r4all_loop[[i]] <- tract %>%
st_transform(crs = epsg_id) %>%
st_geometry() %>%
.[[i]] %>%
get_r(epsg_id = epsg_id)
}
r4all_loop <- bind_rows(r4all_loop)
# We use a functional (sapply) to apply this custom function to each Census Tract.
r4all_apply <- tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
# Are these two identical?
identical(r4all_apply, r4all_loop)
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
tmap_mode('view')
ready_4_yelp
?str_detect
library(tidyverse)
?str_detect
a <- c("yoga", "yoga, tie")
str_detect(a, "yoga")
a <- c("yoga", "yoga, tie", "he")
str_detect(a, "yoga")
str_detect(a, ['yoga'])
str_detect(a, '[yoga]')
str_detect(a, '[Yoga]')
xaringan:::inf_mr()
grepl("yoga", c("yoga studio", "health gym", "pizza", "Yoga"))
str_detect(c("yoga studio", "health gym", "pizza", "Yoga"), "yoga")
grepl("[yY]", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[yYgG]", c("yoga studio", "health gym", "pizza", "Yoga"))
?grepl
?str_detect
grepl("[(yoga)|(Yoga)]", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[Yoga]", c("yoga studio", "health gym", "pizza", "Yoga"))
a <- read_rds("C:/Users/bonwo/Downloads/yelp_all_list_4_Anuradha.rds")
a
aa <- bind_rows(a)
aa
aa$categories
grepl("yoga", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("yoga", c("yoga studio", "health gym", "pizza", "Yoga"), fixed = F)
grepl("Yoga", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[yY]oga", c("yoga studio", "health gym", "pizza", "Yoga"))
grepl("[yY]oga", c("yoga studio", "health gym", "pizza", "Yoga power"))
grepl("[yY]oga", c("yoga studio", "health gym", "pizza", "YoGa power"))
?grepl
xaringan:::inf_mr()
xaringan:::inf_mr()
source("~/.active-rstudio-document", echo=TRUE)
tfruns::training_run("D:/Dropbox (GaTech)/Work/Working/School/UA_2022/external/Lab/module_1/week2/Module1_Tidy_Yelp_Slide.Rmd")
xaringan:::inf_mr()
library(jsonlite)
subhro_file <- readRDS("C:/Users/bkoo34/Downloads/subhro_file.rds")
library(tidyverse)
library(jsonlite)
library(sf)
df <-   subhro_file
df
jsonlite::flatten(df)
df <- subhro_file
jsonlite::flatten(df)
df %>%
st_set_geometry(NULL) %>%
jsonlite::flatten()
library(tidyverse)
library(jsonlite)
library(sf)
df <- subhro_file
jsonlite::flatten(df)
# Import required packages
library(tidytransit)
library(tidyverse)
library(tmap)
library(ggplot2)
library(gtfsrouter)
library(here)
library(units)
library(sf)
library(leaflet)
library(tidycensus)
library(plotly)
library(igraph)
library(tidygraph)
library(dodgr)
library(leafsync)
source("https://raw.githubusercontent.com/BonwooKoo/gtfs_to_igraph/master/gtfs_to_igraph.R")
wd <- file.path(Sys.getenv('setwd'),"work/working/School/UA_2022/external/Lab/module_2")
setwd(eval(wd))
# This GTFS file is downloaded from
# https://opendata.atlantaregional.com/datasets/marta-gtfs-latest-feed/about
atl <- read_gtfs('MARTA_GTFS_Latest_Feed.zip')
typeof(atl)
names(atl)
print(head(atl))
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
head(atlsf)
a <- leaflet(atlsf$shapes) %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addPolylines(weight = 1, color = "red") %>%
addControl(htmltools::HTML("Route shapes"))
b <- leaflet(atlsf$stops) %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircles(weight = 3, color = "red") %>%
addControl(htmltools::HTML("Stop shapes"))
leafsync::sync(a,b)
atl
atl$stops
atlsf <- tidytransit::gtfs_as_sf(atl, crs = 4326)
head(atlsf)
atl
atlsf
tmap_mode()
tmap_mode('view')
tm_shape(atlsf$stops) + tm_dots()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
# tidycensus::census_api_key(Sys.getenv("census_api"), install = TRUE)
library(tidycensus)
library(sf)
library(tmap)
library(jsonlite)
library(tidyverse)
library(httr)
library(jsonlite)
library(reshape2)
library(here)
library(yelpr)
library(knitr)
# Download data from Census 2020 - here we are downloading income, race, and means of transportation to work
FD_tract <- suppressMessages(
get_acs(geography = "tract", # or "block group", "county", "state" etc.
state = "GA",
county = c("Fulton", "Dekalb"),
variables = c(hhincome = 'B19019_001',
race.tot = "B02001_001",
race.white = "B02001_002",
race.black = "B02001_003",
trans.total = "B08006_001",
trans.car = "B08006_002",
trans.drovealone = "B08006_003",
trans.carpooled = "B08006_004", # Notice that I was not interested in 005-007 (2 person/ 4 person carpool etc.)
trans.pubtrans = "B08006_008", # Did not want to download any details about the type of public transport (009-0013)
trans.bicycle = "B08006_014",
trans.walk = "B08006_015",
trans.WfH = "B08006_017"
),
year = 2020,
survey = "acs5", # American Community Survey 5-year estimate
geometry = TRUE, # returns sf objects
output = "wide") # wide vs. long
)
# The data contains several redundant columns that we will not use. So, let's subset the data to only have the columns we will use
FD_tract <- FD_tract %>%
select(GEOID,
hhincome = hhincomeE, # New name = old name
race.tot = race.totE,
race.white = race.whiteE,
race.black = race.blackE,
trans.total = trans.totalE,
trans.car = trans.carE,
trans.drovealone = trans.drovealoneE,
trans.carpooled = trans.carpooledE,
trans.pubtrans = trans.pubtransE,
trans.bicycle = trans.bicycleE,
trans.walk = trans.walkE,
trans.WfH = trans.WfHE)
tmap_mode("view")
## tmap mode set to interactive viewing
tm_shape(FD_tract) + tm_borders()
# Function: Get tract-wise radius
epsg_id <- 4326
get_r <- function(poly, epsg_id){
#---------------------
# Takes: a single POLYGON or LINESTRTING
# Outputs: distance between the centroid of the boundingbox and a corner of the bounding box
#---------------------
# Get bounding box of a given polygon
bb <- st_bbox(poly)
# Get lat & long coordinates of any one corner of the bounding box.
bb_corner <- st_point(c(bb[1], bb[2])) %>% st_sfc(crs = epsg_id)
# Get centroid of the bb
bb_center_x <- (bb[3]+bb[1])/2
bb_center_y <- (bb[4]+bb[2])/2
bb_center <- st_point(c(bb_center_x, bb_center_y)) %>% st_sfc(crs = epsg_id) %>% st_sf()
# Get the distance between bb_p and c
r <- st_distance(bb_corner, bb_center)
# Multiply 1.1 to make the circle a bit larger than the Census Tract.
# See the Yelp explanation of their radius parameter to see why we do this.
bb_center$radius <- r*1.2
return(bb_center)
}
# Using a functional -----------------------------------------------------------
# We use a functional (lapply) to apply this custom function to each Census Tract.
r4all_apply <- FD_tract %>%
st_geometry() %>%
st_transform(crs = epsg_id) %>%
lapply(., function(x) get_r(x, epsg_id = epsg_id))
r4all_apply <- bind_rows(r4all_apply)
ready_4_yelp <- r4all_apply %>%
mutate(x = st_coordinates(.)[,1],
y = st_coordinates(.)[,2])
# Select the first 10 rows
ready_4_yelp[1:10,] %>%
# Draw a buffer centered at the centroid of Tract polygons.
# Radius of the buffer is the radius we just calculated using loop
st_buffer(., dist = .$radius) %>%
# Display this buffer in red
tm_shape(.) + tm_polygons(alpha = 0.5, col = 'red') +
# Display the original polygon in blue
tm_shape(FD_tract[1:10,]) + tm_borders(col= 'blue')
## =========================================================================
## Starting Yelp API call and data capture process
get_yelp <- function(tract, category){
# ----------------------------------
# Gets one row of tract information (1,) and category name (str),
# Outputs a list of business data.frame
n <- 1
# First request --------------------------------------------------------------
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50, # = 0 when n = 1
radius = round(tract$radius),
limit = 50)
# Calculate how many requests are needed in total
required_n <- ceiling(resp$total/50)
# out is where the results will be appended to.
out <- vector("list", required_n)
# Store the business information to nth slot in out
out[[n]] <- resp$businesses
# Change the name of the elements to the total required_n
# This is to know if there are more than 1000 businesses,
# we know how many.
names(out)[n] <- required_n
# Throw error if more than 1000
if (resp$total >= 1000)
{
# glue formats string by inserting {n} with what's currently stored in object n.
print(glue::glue("{n}th row has >= 1000 businesses."))
# Stop before going into the loop because we need to
# break down Census Tract to something smaller.
return(out)
}
else
{
# add 1 to n
n <- n + 1
# Now we know required_n -----------------------------------------------------
# Starting a loop
while(n <= required_n){
resp <- business_search(api_key = Sys.getenv("yelp_api"),
categories = category,
latitude = tract$y,
longitude = tract$x,
offset = (n - 1) * 50,
radius = round(tract$radius),
limit = 50)
out[[n]] <- resp$businesses
n <- n + 1
} #<< end of while loop
# Merge all elements in the list into a single data frame
out <- out %>% bind_rows()
return(out)
}
}
# Get data for the first tract
yelp_first_tract <- get_yelp(ready_4_yelp[1,], "yoga") %>%
as_tibble()
# Prepare a collector
yelp_all_list <- vector("list", nrow(ready_4_yelp))
# Looping through all Census Tracts
for (row in 1:nrow(ready_4_yelp)){
yelp_all_list[[row]] <- suppressMessages(get_yelp(ready_4_yelp[row,], "yoga"))
if (row %% 50 == 0){
print(paste0("Current row: ", row))
}
}
library(tidyverse)
library(sf)
df <- st_read("yelp_census_Subhro.geojson")
df <- st_read("C:/Users/bkoo34/Downloads/yelp_census_Subhro.geojson")
df
library(tmap)
tmap_mode('veiw')
tmap_mode('view')
tm_shape(df) +tm_borders()
df
tm_shape(df) +tm_dots()
df$categories
df
