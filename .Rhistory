for (i in 1:nrow(temp_point)){
j <- i*2 - 1
temp_point[i, "azi"] <- sampled_azi %>%
st_cast("POINT") %>%
st_geometry() %>%
.[j:(j+1)] %>%
st_coordinates() %>%
as.data.frame() %>%
with(
.[2,] - .[1,]
) %>%
with(
atan2(.[["X"]], .[["Y"]])*180/pi
)
}
temp_point
# What % is 20m?
z <- edges %>% filter(edge_id == 234)
z
tm_shape(z) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 2334)
tm_shape(z) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 23334)
tm_shape(z) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 24)
tm_shape(z) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 2489)
tm_shape(z) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 248)
tm_shape(z) + tm_lines()
tm_shape(edges) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 27739)
tm_shape(z) + tm_lines()
# What % is 20m?
z <- edges %>% filter(edge_id == 27739)
tm_shape(z) + tm_lines()
# Extract a curvy line
z <- edges %>% filter(edge_id == 27739)
tm_shape(z) + tm_lines()
# calculate what proportion equals 40 in the given segment
prop <- 40/z$length
# Vector for actual points
sample_actual <- c(seq(0, 1, by=prop),1)
# Vector for two points before/after the actual points for azimuth calculation
sample_azi <- c(sample_actual-0.02, sample_actual+0.02) %>% sort()
sampled_actual <- z %>% st_transform(26967) %>% st_line_sample(sample = sample_actual) %>% st_cast("POINT")
sampled_azi <- z %>% st_transform(26967) %>% st_line_sample(sample = sample_azi) %>% st_cast("POINT")
# Sample points
sampled_actual <- z %>% st_transform(26967) %>% st_line_sample(sample = sample_actual) %>% st_cast("POINT")
sampled_azi <- z %>% st_transform(26967) %>% st_line_sample(sample = sample_azi) %>% st_cast("POINT")
# View them
tm_shape(sampled_actual) + tm_dots(col = "red", size=0.07) +
tm_shape(sampled_azi) + tm_dots(col = "blue", alpha = 0.5)
# Extract a curvy line
z <- edges %>% filter(edge_id == 27739)
tm_shape(z) + tm_lines()
# calculate what proportion equals 40 in the given segment
prop <- 40/z$length
# Vector for actual points
sample_actual <- c(seq(0, 1, by=prop),1)
# Vector for two points before/after the actual points for azimuth calculation
sample_azi <- c(sample_actual-0.02, sample_actual+0.02) %>% sort()
# Sample points
sampled_actual <- z %>% st_transform(26967) %>% st_line_sample(sample = sample_actual) %>% st_cast("POINT")
sampled_azi <- z %>% st_transform(26967) %>% st_line_sample(sample = sample_azi) %>% st_cast("POINT")
# View them
tm_shape(sampled_actual) + tm_dots(col = "red", size=0.07) +
tm_shape(sampled_azi) + tm_dots(col = "blue", alpha = 0.5)
temp_point <- sampled_actual %>%
st_sf() %>%
mutate(azi = NA)
temp_point
for (i in 1:nrow(temp_point)){
j <- i*2 - 1
temp_point[i, "azi"] <- sampled_azi %>%
st_cast("POINT") %>%
st_geometry() %>%
.[j:(j+1)] %>%
st_coordinates() %>%
as.data.frame() %>%
with(
.[2,] - .[1,]
) %>%
with(
atan2(.[["X"]], .[["Y"]])*180/pi
)
}
temp_point
sampled_actual
#
point_azi <- sampled_actual %>%
st_sf() %>%
mutate(azi = NA)
for (i in 1:nrow(temp_point)){
j <- i*2 - 1
point_azi[i, "azi"] <- sampled_azi %>%
st_cast("POINT") %>%
.[j:(j+1)] %>%
st_coordinates() %>%
as.data.frame() %>%
with(
.[2,] - .[1,]
) %>%
with(
atan2(.[["X"]], .[["Y"]])*180/pi
)
}
point_azi
#
point_azi <- sampled_actual %>%
st_sf() %>%
mutate(azi = NA)
for (i in 1:nrow(temp_point)){
j <- i*2 - 1
point_azi[i, "azi"] <- sampled_azi %>%
st_cast("POINT") %>%
.[j:(j+1)] %>%
st_coordinates() %>%
with(
.[2,] - .[1,]
) %>%
with(
atan2(.[["X"]], .[["Y"]])*180/pi
)
}
library(tidyverse)
library(osmdata)
library(sfnetworks)
library(units)
library(sf)
library(tidygraph)
library(tmap)
library(here)
# Bounding Box for Atlanta.
bb_atl <- getbb("Atlanta,GA")
# Get OSM data.
osm_road <- opq(bbox = bb_atl) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
# Convert the OSM line to sfnetworks and clean it.
net <- sfnetworks::as_sfnetwork(osm_road$osm_lines ,directed = FALSE) %>%
activate("edges") %>%
filter(!edge_is_multiple()) %>%
filter(!edge_is_loop()) %>%
convert(., sfnetworks::to_spatial_subdivision) %>%
convert(., sfnetworks::to_spatial_smooth) %>%
mutate(legnth = edge_length())
edges <- net %>%
# Extract 'edges'
st_as_sf("edges") %>%
# Drop redundant columns
select(osm_id, highway) %>%
# Add length column
mutate(length = st_length(.) %>% unclass()) %>%
# Drop segments that are too short (100m)
filter(length > 100) %>%
# Add a unique ID for each edge
mutate(edge_id = seq(1,nrow(.)))
# nodes <- net %>%
#   st_as_sf("nodes") %>%
#   mutate(node_id = seq(1,nrow(.)))
# Select an edge for demo
test_edge = 23126
e <- edges %>% filter(edge_id == test_edge)
# View it
tmap_mode('view')
e %>% st_coordinates() %>%
as.data.frame() %>%
st_as_sf(coords = c("X", "Y"), crs = 4326) %>%
with(
tm_shape(.) + tm_dots() +
tm_shape(.[1,]) + tm_dots(col = "red") +  # Start = red
tm_shape(.[nrow(.),]) + tm_dots(col = "yellow")  # End = yellow
)
# -----------------------------------------------------------
# First intersection
# First two points from a line
start_p <- e %>%
st_coordinates() %>%
.[1:2,1:2]
# Calculate the azimuth of the line connecting the two points
start_azi <- atan2(start_p[2,"X"] - start_p[1, "X"],
start_p[2,"Y"] - start_p[1, "Y"])*180/pi # 180/pi because trigonometry in R takes radians
# -----------------------------------------------------------
# The other intersection
# Last two points from a line
end_p <- e %>%
st_coordinates() %>%
.[(nrow(.)-1):nrow(.),1:2]
# Calculate the azimuth of the line connecting the two points
end_azi <- atan2(end_p[2,"X"] - end_p[1, "X"],
end_p[2,"Y"] - end_p[1, "Y"])*180/pi
# Flip the azimuth so that the camera would be looking back
end_azi <- if (end_azi < 180) {end_azi + 180} else {end_azi - 180}
# ----------------------------------------------------------
# mid point
mid_p <- e %>%
st_geometry() %>%
.[[1]] %>%
st_line_sample(sample = c(0.45, 0.55)) %>%
st_cast("POINT") %>%
st_coordinates()
mid_azi <- atan2(mid_p[2,"X"] - mid_p[1, "X"],
mid_p[2,"Y"] - mid_p[1, "Y"])*180/pi
mid_p <- e %>%
st_geometry() %>%
.[[1]] %>%
st_line_sample(sample = 0.5) %>%
st_coordinates() %>%
.[1,1:2]
get_azi <- function(line){
# end point 1 ----------------------------------------------
start_p <- line %>%
st_coordinates() %>%
.[1:2,1:2]
start_azi <- atan2(start_p[2,"X"] - start_p[1, "X"],
start_p[2,"Y"] - start_p[1, "Y"])*180/pi
# end point 2 ----------------------------------------------
end_p <- line %>%
st_coordinates() %>%
.[(nrow(.)-1):nrow(.),1:2]
end_azi <- atan2(end_p[2,"X"] - end_p[1, "X"],
end_p[2,"Y"] - end_p[1, "Y"])*180/pi
end_azi <- if (end_azi < 180) {end_azi + 180} else {end_azi - 180}
# mid point 1 ---------------------------------------------
mid_p <- line %>%
st_line_sample(sample = c(0.45, 0.55)) %>%
st_cast("POINT") %>%
st_coordinates()
mid_azi <- atan2(mid_p[2,"X"] - mid_p[1, "X"],
mid_p[2,"Y"] - mid_p[1, "Y"])*180/pi
mid_p <- line %>%
st_line_sample(sample = 0.5) %>%
st_coordinates() %>%
.[1,1:2]
# return in data frame ------------------------------------
return(tribble(
~type,    ~X,            ~Y,             ~azi,
"start",   start_p[1,"X"], start_p[1,"Y"], start_azi,
"mid1",    mid_p["X"],   mid_p["Y"],   mid_azi,
"mid2",    mid_p["X"],   mid_p["Y"],   ifelse(mid_azi < 180, mid_azi + 180, mid_azi - 180),
"end",     end_p[2,"X"],   end_p[2,"Y"],   end_azi))
}
endp_azi <- edges %>%
st_geometry() %>%
map_df(get_azi)
endp <- endp_azi %>%
bind_cols(edges %>%
st_drop_geometry() %>%
slice(rep(1:nrow(edges),each=4))) %>%
st_as_sf(coords = c("X", "Y"), crs = 4326, remove=FALSE) %>%
mutate(node_id = seq(1, nrow(.)))
endp
# st_write(endp, "C:/Users/bonwo/Downloads/endp.geojson", delete_dsn = T)
# st_write(edges, "C:/Users/bonwo/Downloads/edges.geojson", delete_dsn = T)
get_image <- function(iterrow){
type = iterrow$type
location <- paste0(iterrow$Y %>% round(4), ",", iterrow$X %>% round(4))
heading <- iterrow$azi %>% round(1)
edge_id <- iterrow$edge_id
node_id <- iterrow$node_id
highway <- iterrow$highway
key <- Sys.getenv("google_api")
furl <- glue::glue("https://maps.googleapis.com/maps/api/streetview?size=640x640&location={location}&heading={heading}&fov=90&pitch=0&key={key}")
fname <- glue::glue("GSV-nid_{node_id}-eid_{edge_id}-type_{type}-Location_{location}-heading_{heading}-highway_{highway}.jpg")
fpath <- here("Lab", "module_3", "downloaded_image", fname)
download.file(furl, fpath, mode = 'wb')
}
edges
st_write(edges, "C:/Users/bkoo34/Downloads/edges.geojson", delete_dsn = T)
library(tidyverse)
library(osmdata)
library(sfnetworks)
library(units)
library(sf)
library(tidygraph)
library(tmap)
library(here)
# Bounding Box for Atlanta.
bb_atl <- getbb("Atlanta,GA")
# Get OSM data.
osm_road <- opq(bbox = bb_atl) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
# Convert the OSM line to sfnetworks and clean it.
net <- sfnetworks::as_sfnetwork(osm_road$osm_lines ,directed = FALSE) %>%
activate("edges") %>%
filter(!edge_is_multiple()) %>%
filter(!edge_is_loop()) %>%
convert(., sfnetworks::to_spatial_subdivision) %>%
convert(., sfnetworks::to_spatial_smooth) %>%
mutate(legnth = edge_length())
edges <- net %>%
# Extract 'edges'
st_as_sf("edges") %>%
# Drop redundant columns
select(osm_id, highway) %>%
# Add length column
mutate(length = st_length(.) %>% unclass()) %>%
# Drop segments that are too short (100m)
filter(length > 50) %>%
# Add a unique ID for each edge
mutate(edge_id = seq(1,nrow(.)))
# nodes <- net %>%
#   st_as_sf("nodes") %>%
#   mutate(node_id = seq(1,nrow(.)))
# Select an edge for demo
test_edge = 23126
e <- edges %>% filter(edge_id == test_edge)
# View it
tmap_mode('view')
e %>% st_coordinates() %>%
as.data.frame() %>%
st_as_sf(coords = c("X", "Y"), crs = 4326) %>%
with(
tm_shape(.) + tm_dots() +
tm_shape(.[1,]) + tm_dots(col = "red") +  # Start = red
tm_shape(.[nrow(.),]) + tm_dots(col = "yellow")  # End = yellow
)
st_write(edges, "C:/Users/bkoo34/Downloads/edges.geojson", delete_dsn = T)
# Download images
edges_gt <- st_read("C:/Users/bkoo34/Downloads/edge_gt.geojson")
# Download images
edges_gt <- st_read("C:/Users/bkoo34/Downloads/edges_gt.geojson")
# Download images
edges_gt <- st_read("C:/Users/bkoo34/Downloads/edges.geojson")
# Download images
edges_gt <- st_read("C:/Users/bkoo34/Downloads/edges.geojson")
# Loop!
for (i in seq(1,nrow(edges_gt))){
get_image(edges_gt[i,])
}
get_image <- function(iterrow){
type = iterrow$type
location <- paste0(iterrow$Y %>% round(4), ",", iterrow$X %>% round(4))
heading <- iterrow$azi %>% round(1)
edge_id <- iterrow$edge_id
node_id <- iterrow$node_id
highway <- iterrow$highway
key <- Sys.getenv("google_api")
furl <- glue::glue("https://maps.googleapis.com/maps/api/streetview?size=640x640&location={location}&heading={heading}&fov=90&pitch=0&key={key}")
fname <- glue::glue("GSV-nid_{node_id}-eid_{edge_id}-type_{type}-Location_{location}-heading_{heading}-highway_{highway}.jpg")
fpath <- here("Lab", "module_3", "downloaded_image", fname)
download.file(furl, fpath, mode = 'wb')
}
edges_gt
endp_azi
endp_azi
endp <- endp_azi %>%
bind_cols(edges %>%
st_drop_geometry() %>%
slice(rep(1:nrow(edges),each=4))) %>%
st_as_sf(coords = c("X", "Y"), crs = 4326, remove=FALSE) %>%
mutate(node_id = seq(1, nrow(.)))
endp
library(tidyverse)
library(osmdata)
library(sfnetworks)
library(units)
library(sf)
library(tidygraph)
library(tmap)
library(here)
# Bounding Box for Atlanta.
bb_atl <- getbb("Atlanta,GA")
# Get OSM data.
osm_road <- opq(bbox = bb_atl) %>%
add_osm_feature(key = 'highway',
value = c("motorway", "trunk", "primary",
"secondary", "tertiary", "unclassified",
"residential")) %>%
osmdata_sf() %>%
osm_poly2line()
# Convert the OSM line to sfnetworks and clean it.
net <- sfnetworks::as_sfnetwork(osm_road$osm_lines ,directed = FALSE) %>%
activate("edges") %>%
filter(!edge_is_multiple()) %>%
filter(!edge_is_loop()) %>%
convert(., sfnetworks::to_spatial_subdivision) %>%
convert(., sfnetworks::to_spatial_smooth) %>%
mutate(legnth = edge_length())
edges <- net %>%
# Extract 'edges'
st_as_sf("edges") %>%
# Drop redundant columns
select(osm_id, highway) %>%
# Add length column
mutate(length = st_length(.) %>% unclass()) %>%
# Drop segments that are too short (100m)
filter(length > 50) %>%
# Add a unique ID for each edge
mutate(edge_id = seq(1,nrow(.)))
# nodes <- net %>%
#   st_as_sf("nodes") %>%
#   mutate(node_id = seq(1,nrow(.)))
# Select an edge for demo
test_edge = 23126
e <- edges %>% filter(edge_id == test_edge)
# View it
tmap_mode('view')
e %>% st_coordinates() %>%
as.data.frame() %>%
st_as_sf(coords = c("X", "Y"), crs = 4326) %>%
with(
tm_shape(.) + tm_dots() +
tm_shape(.[1,]) + tm_dots(col = "red") +  # Start = red
tm_shape(.[nrow(.),]) + tm_dots(col = "yellow")  # End = yellow
)
# -----------------------------------------------------------
# First intersection
# First two points from a line
start_p <- e %>%
st_coordinates() %>%
.[1:2,1:2]
# Calculate the azimuth of the line connecting the two points
start_azi <- atan2(start_p[2,"X"] - start_p[1, "X"],
start_p[2,"Y"] - start_p[1, "Y"])*180/pi # 180/pi because trigonometry in R takes radians
# -----------------------------------------------------------
# The other intersection
# Last two points from a line
end_p <- e %>%
st_coordinates() %>%
.[(nrow(.)-1):nrow(.),1:2]
# Calculate the azimuth of the line connecting the two points
end_azi <- atan2(end_p[2,"X"] - end_p[1, "X"],
end_p[2,"Y"] - end_p[1, "Y"])*180/pi
# Flip the azimuth so that the camera would be looking back
end_azi <- if (end_azi < 180) {end_azi + 180} else {end_azi - 180}
# ----------------------------------------------------------
# mid point
mid_p <- e %>%
st_geometry() %>%
.[[1]] %>%
st_line_sample(sample = c(0.45, 0.55)) %>%
st_cast("POINT") %>%
st_coordinates()
mid_azi <- atan2(mid_p[2,"X"] - mid_p[1, "X"],
mid_p[2,"Y"] - mid_p[1, "Y"])*180/pi
mid_p <- e %>%
st_geometry() %>%
.[[1]] %>%
st_line_sample(sample = 0.5) %>%
st_coordinates() %>%
.[1,1:2]
get_azi <- function(line){
# end point 1 ----------------------------------------------
start_p <- line %>%
st_coordinates() %>%
.[1:2,1:2]
start_azi <- atan2(start_p[2,"X"] - start_p[1, "X"],
start_p[2,"Y"] - start_p[1, "Y"])*180/pi
# end point 2 ----------------------------------------------
end_p <- line %>%
st_coordinates() %>%
.[(nrow(.)-1):nrow(.),1:2]
end_azi <- atan2(end_p[2,"X"] - end_p[1, "X"],
end_p[2,"Y"] - end_p[1, "Y"])*180/pi
end_azi <- if (end_azi < 180) {end_azi + 180} else {end_azi - 180}
# mid point 1 ---------------------------------------------
mid_p <- line %>%
st_line_sample(sample = c(0.45, 0.55)) %>%
st_cast("POINT") %>%
st_coordinates()
mid_azi <- atan2(mid_p[2,"X"] - mid_p[1, "X"],
mid_p[2,"Y"] - mid_p[1, "Y"])*180/pi
mid_p <- line %>%
st_line_sample(sample = 0.5) %>%
st_coordinates() %>%
.[1,1:2]
# return in data frame ------------------------------------
return(tribble(
~type,    ~X,            ~Y,             ~azi,
"start",   start_p[1,"X"], start_p[1,"Y"], start_azi,
"mid1",    mid_p["X"],   mid_p["Y"],   mid_azi,
"mid2",    mid_p["X"],   mid_p["Y"],   ifelse(mid_azi < 180, mid_azi + 180, mid_azi - 180),
"end",     end_p[2,"X"],   end_p[2,"Y"],   end_azi))
}
endp_azi <- edges %>%
st_geometry() %>%
map_df(get_azi)
endp <- endp_azi %>%
bind_cols(edges %>%
st_drop_geometry() %>%
slice(rep(1:nrow(edges),each=4))) %>%
st_as_sf(coords = c("X", "Y"), crs = 4326, remove=FALSE) %>%
mutate(node_id = seq(1, nrow(.)))
endp
# st_write(endp, "C:/Users/bonwo/Downloads/endp.geojson", delete_dsn = T)
# st_write(edges, "C:/Users/bonwo/Downloads/edges.geojson", delete_dsn = T)
st_write(endp, "C:/Users/bkoo34/Downloads/endp.geojson", delete_dsn = T)
# Download images
edges_gt <- st_read(here("Lab", "module_3", "endp_gt.geojson"))
# Loop!
for (i in seq(1,nrow(edges_gt))){
get_image(edges_gt[i,])
}
# Extract a curvy line
z <- edges %>% filter(edge_id == test_edge)
